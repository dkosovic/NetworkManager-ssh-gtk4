diff --git a/.gitignore b/.gitignore
index 5a28f98..6b70643 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,11 @@
 # Object files
 *.o
+*.lo
 
 # Libraries
 *.lib
 *.a
+*.la
 
 # Shared objects (inc. Windows DLLs)
 *.dll
@@ -17,6 +19,7 @@
 *.app
 
 autom4te.cache/
+gtk4/
 Makefile
 Makefile.in
 
@@ -33,5 +36,6 @@ ltmain.sh
 missing
 nm-ssh-service.name
 stamp-h1
+properties/resources.c
 
 /NetworkManager-ssh-*.tar*
diff --git a/Makefile.am b/Makefile.am
index 6ee2c87..37eca40 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,10 +1,10 @@
-AUTOMAKE_OPTIONS = foreign
+AUTOMAKE_OPTIONS = foreign subdir-objects
 
-SUBDIRS = src
+SUBDIRS = . po
 
-if WITH_GNOME
-SUBDIRS += auth-dialog properties po
-endif
+CLEANFILES =
+
+DISTCHECK_CONFIGURE_FLAGS = --with-tests=yes
 
 dbusservicedir = $(sysconfdir)/dbus-1/system.d
 dbusservice_DATA = nm-ssh-service.conf
@@ -12,6 +12,10 @@ dbusservice_DATA = nm-ssh-service.conf
 nmvpnservicedir = $(NM_VPN_SERVICE_DIR)
 nmvpnservice_DATA = nm-ssh-service.name
 
+plugindir = $(libdir)/NetworkManager
+
+libexec_PROGRAMS =
+
 if WITH_LIBNM_GLIB
 # Install a file with full path to plugins for an old gnome-shell
 # https://bugzilla.gnome.org/show_bug.cgi?id=693590
@@ -51,19 +55,32 @@ nm-ssh-service.name: $(srcdir)/nm-ssh-service.name.in
 	    -e 's|[@]PLUGINDIR[@]/|@NM_PLUGIN_DIR@|g' \
 	    $< >$@
 
-DISTCHECK_CONFIGURE_FLAGS = --with-tests=yes
-
 EXTRA_DIST = nm-ssh-service.name.in \
 	$(dbusservice_DATA) \
 	$(desktopfile) \
 	$(iconfile) \
 	$(appdata_in_files) \
 	$(appdata_DATA) \
+	properties/nm-ssh-dialog.ui \
+	properties/gresource.xml \
 	intltool-extract.in \
 	intltool-merge.in \
-	intltool-update.in
+	intltool-update.in \
+	\
+	shared/README \
+	shared/nm-service-defines.h \
+	shared/nm-default.h \
+	shared/nm-utils/nm-test-utils.h \
+	shared/nm-utils/nm-vpn-plugin-utils.c \
+	shared/nm-utils/gsystem-local-alloc.h \
+	shared/nm-utils/nm-shared-utils.h \
+	shared/nm-utils/nm-glib.h \
+	shared/nm-utils/nm-vpn-plugin-utils.h \
+	shared/nm-utils/nm-macros-internal.h \
+	shared/nm-utils/nm-vpn-plugin-macros.h \
+	shared/nm-utils/nm-shared-utils.c
 
-CLEANFILES = $(nmvpnservice_DATA) \
+CLEANFILES += $(nmvpnservice_DATA) \
 	$(desktop_DATA) \
 	$(appdata_DATA)
 
@@ -130,3 +147,147 @@ deb: changelog dist-xz
 	dpkg-buildpackage -B -nc
 
 .PHONY: rpm deb changelog
+
+AM_CPPFLAGS = \
+	$(LIBNM_CFLAGS) \
+	$(GIO_CFLAGS) \
+	-DNM_SSH_LOCALEDIR=\"$(datadir)/locale\" \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/shared/
+
+libexec_PROGRAMS += nm-ssh-service
+
+nm_ssh_service_SOURCES = \
+	src/nm-ssh-service.c \
+	src/nm-ssh-service.h \
+	shared/nm-service-defines.h
+
+nm_ssh_service_LDADD = \
+	$(LIBNM_LIBS) $(GIO_LIBS)
+
+properties/resources.c: properties/gresource.xml $(shell $(GLIB_COMPILE_RESOURCES) --sourcedir=$(srcdir)/properties --generate-dependencies $(srcdir)/properties/gresource.xml)
+	$(AM_V_GEN) $(GLIB_COMPILE_RESOURCES) $< --target=$@ --sourcedir=$(srcdir)/properties --generate-source --internal
+
+gtk4/resources.c: properties/gresource.xml $(shell $(GLIB_COMPILE_RESOURCES) --generate-dependencies $(srcdir)/properties/gresource.xml |sed "s,^,$(builddir)/gtk4/,")
+	@mkdir -p $(builddir)/gtk4
+	$(AM_V_GEN) $(GLIB_COMPILE_RESOURCES) $< --target=$@ --sourcedir=$(srcdir)/gtk4 --sourcedir=$(builddir)/gtk4 --generate-source --internal
+
+gtk4/%.ui: properties/%.ui
+	@mkdir -p $(builddir)/gtk4
+	gtk4-builder-tool simplify --3to4 $< |grep -v can-default >$@
+
+# Include a prebuilt file in tarball, to avoid hitting
+# https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/4415
+EXTRA_DIST += \
+	gtk4/nm-ssh-dialog.ui
+
+###################################################################################################
+
+plugin_LTLIBRARIES = properties/libnm-vpn-plugin-ssh.la
+
+properties_libnm_vpn_plugin_ssh_la_SOURCES = \
+	shared/nm-utils/nm-vpn-plugin-utils.c \
+	shared/nm-utils/nm-vpn-plugin-utils.h \
+	properties/nm-ssh-editor-plugin.c \
+	properties/nm-ssh-editor-plugin.h
+
+properties_libnm_vpn_plugin_ssh_la_CFLAGS = \
+	$(LIBNM_CFLAGS)
+
+properties_libnm_vpn_plugin_ssh_la_LIBADD = \
+	$(LIBNM_LIBS)
+
+properties_libnm_vpn_plugin_ssh_la_LDFLAGS = \
+	-avoid-version
+
+###################################################################################################
+
+if WITH_GNOME
+plugin_LTLIBRARIES += properties/libnm-gtk3-vpn-plugin-ssh-editor.la
+endif
+
+properties_libnm_gtk3_vpn_plugin_ssh_editor_la_SOURCES = \
+	properties/nm-ssh-editor.c \
+	properties/nm-ssh-editor.h \
+	properties/advanced-dialog.c \
+	properties/advanced-dialog.h
+
+nodist_properties_libnm_gtk3_vpn_plugin_ssh_editor_la_SOURCES = \
+	properties/resources.c
+
+properties_libnm_gtk3_vpn_plugin_ssh_editor_la_CFLAGS = \
+	$(GTK_CFLAGS) \
+	$(LIBNM_CFLAGS)
+
+properties_libnm_gtk3_vpn_plugin_ssh_editor_la_LIBADD = \
+	$(GTK_LIBS) \
+	$(LIBNM_LIBS)
+
+properties_libnm_gtk3_vpn_plugin_ssh_editor_la_LDFLAGS = \
+	-avoid-version
+
+###################################################################################################
+
+if WITH_GTK4
+plugin_LTLIBRARIES += properties/libnm-gtk4-vpn-plugin-ssh-editor.la
+endif
+
+properties_libnm_gtk4_vpn_plugin_ssh_editor_la_SOURCES = \
+	$(properties_libnm_gtk3_vpn_plugin_ssh_editor_la_SOURCES)
+
+nodist_properties_libnm_gtk4_vpn_plugin_ssh_editor_la_SOURCES = \
+	gtk4/resources.c
+
+properties_libnm_gtk4_vpn_plugin_ssh_editor_la_CFLAGS = \
+	$(GTK4_CFLAGS) \
+	$(LIBNM_CFLAGS)
+
+properties_libnm_gtk4_vpn_plugin_ssh_editor_la_LIBADD = \
+	$(GTK4_LIBS) \
+	$(LIBNM_LIBS)
+
+properties_libnm_gtk4_vpn_plugin_ssh_editor_la_LDFLAGS = \
+	$(properties_libnm_gtk3_vpn_plugin_ssh_editor_la_LDFLAGS)
+
+###################################################################################################
+
+if WITH_LIBNM_GLIB
+plugin_LTLIBRARIES += properties/libnm-ssh-properties.la
+endif
+
+properties_libnm_ssh_properties_la_SOURCES = \
+	$(properties_libnm_gtk3_vpn_plugin_ssh_editor_la_SOURCES) \
+	$(libnm_vpn_plugin_ssh_la_SOURCES)
+
+properties_libnm_ssh_properties_la_CFLAGS = \
+	-DNM_SSH_OLD \
+	$(LIBNM_GLIB_CFLAGS)
+
+properties_libnm_ssh_properties_la_LIBADD = \
+	$(GTK_LIBS) \
+	$(LIBNM_GLIB_LIBS)
+
+properties_libnm_ssh_properties_la_LDFLAGS = \
+	$(libnm_vpn_plugin_ssh_la_LDFLAGS)
+
+###################################################################################################
+
+libexec_PROGRAMS += auth_dialog/nm-ssh-auth-dialog
+
+auth_dialog_nm_ssh_auth_dialog_CPPFLAGS = \
+	$(GTK_CFLAGS) \
+	$(LIBSECRET_CFLAGS) \
+	$(LIBNM_CFLAGS) \
+	$(LIBNMA_CFLAGS) \
+	-I$(top_srcdir)/ \
+	-I$(top_srcdir)/shared/
+
+auth_dialog_nm_ssh_auth_dialog_SOURCES = \
+	properties/resources.c \
+	auth-dialog/main.c
+
+auth_dialog_nm_ssh_auth_dialog_LDADD = \
+	$(GTK_LIBS) \
+	$(LIBSECRET_LIBS) \
+	$(LIBNM_LIBS) \
+	$(LIBNMA_LIBS)
diff --git a/auth-dialog/Makefile.am b/auth-dialog/Makefile.am
deleted file mode 100644
index b8d0d8b..0000000
--- a/auth-dialog/Makefile.am
+++ /dev/null
@@ -1,23 +0,0 @@
-libexec_PROGRAMS = nm-ssh-auth-dialog
-
-nm_ssh_auth_dialog_CPPFLAGS = \
-	$(GTK_CFLAGS) \
-	$(LIBSECRET_CFLAGS) \
-	$(LIBNM_CFLAGS) \
-	$(LIBNMA_CFLAGS) \
-	-I$(top_srcdir)/
-	-DICONDIR=\""$(datadir)/pixmaps"\" \
-	-DUIDIR=\""$(uidir)"\" \
-	-DBINDIR=\""$(bindir)"\" \
-	-DGNOMELOCALEDIR=\"$(datadir)/locale\"
-
-nm_ssh_auth_dialog_SOURCES = \
-	main.c
-
-nm_ssh_auth_dialog_LDADD = \
-	$(GTK_LIBS) \
-	$(LIBSECRET_LIBS) \
-	$(LIBNM_LIBS) \
-	$(LIBNMA_LIBS)
-
-CLEANFILES = *~
diff --git a/auth-dialog/main.c b/auth-dialog/main.c
index ea2c8f1..b5d66d5 100644
--- a/auth-dialog/main.c
+++ b/auth-dialog/main.c
@@ -36,7 +36,7 @@
 #include <nma-vpn-password-dialog.h>
 #include <nm-vpn-service-plugin.h>
 
-#include "src/nm-ssh-service-defines.h"
+#include "nm-service-defines.h"
 
 #define KEYRING_UUID_TAG "connection-uuid"
 #define KEYRING_SN_TAG "setting-name"
diff --git a/configure.ac b/configure.ac
index 940993c..4c5c7f5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -8,6 +8,8 @@ AC_CONFIG_MACRO_DIR([m4])
 
 AC_CONFIG_HEADERS([config.h])
 
+AC_USE_SYSTEM_EXTENSIONS
+
 dnl
 dnl Require programs
 dnl
@@ -15,6 +17,7 @@ AC_PROG_CC
 AM_PROG_CC_C_O
 AC_PROG_INSTALL
 AC_PROG_LIBTOOL
+AC_PATH_PROG(GLIB_COMPILE_RESOURCES, glib-compile-resources)
 
 dnl
 dnl Required headers
@@ -28,6 +31,7 @@ dnl
 AC_TYPE_MODE_T
 AC_TYPE_PID_T
 AC_HEADER_TIME
+AC_GNU_SOURCE
 
 dnl
 dnl Checks for library functions.
@@ -49,6 +53,8 @@ dnl GNOME support
 dnl
 AC_ARG_WITH(gnome, AS_HELP_STRING([--without-gnome], [Build NetworkManager-ssh without GNOME support, e.g. vpn service only]))
 AM_CONDITIONAL(WITH_GNOME, test x"$with_gnome" != xno)
+AC_ARG_WITH(gtk4, AS_HELP_STRING([--with-gtk4], [Build NetworkManager-vpnc with libnma-gtk4 support]), [], [with_gtk4_specified=no])
+AM_CONDITIONAL(WITH_GTK4, test x"$with_gtk4" == xyes)
 AC_ARG_WITH(libnm-glib, AS_HELP_STRING([--with-libnm-glib], [Build NetworkManager-ssh without libnm-glib comatibility]))
 AM_CONDITIONAL(WITH_LIBNM_GLIB, test x"$with_libnm_glib" == xyes)
 AC_ARG_ENABLE(absolute-paths, AS_HELP_STRING([--enable-absolute-paths], [Use absolute paths to in .name files. Useful for development. (default is no)]))
@@ -60,13 +66,16 @@ AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"$GETTEXT_PACKAGE", [Gettext package])
 IT_PROG_INTLTOOL([0.35])
 AM_GLIB_GNU_GETTEXT
 
-PKG_CHECK_MODULES(GIO, gio-unix-2.0)
+PKG_CHECK_MODULES(GIO, gio-unix-2.0 >= 2.32)
+GIO_CFLAGS="$GIO_CFLAGS -DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_32"
+GIO_CFLAGS="$GIO_CFLAGS -DGLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_32"
 AC_SUBST(GIO_CFLAGS)
 AC_SUBST(GIO_LIBS)
 
 if test x"$with_gnome" != xno; then
 	PKG_CHECK_MODULES(GTK, gtk+-3.0 >= 3.4)
 	GTK_CFLAGS="$GTK_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_3_4"
+	GTK_CFLAGS="$GTK_CFLAGS -DGDK_VERSION_MAN_REQUIRED=GDK_VERSION_3_4"
 
 	PKG_CHECK_MODULES(LIBNMA, libnma >= 1.1.0)
 	PKG_CHECK_MODULES(LIBSECRET, libsecret-1)
@@ -83,9 +92,14 @@ if test x"$with_gnome" != xno; then
 	fi
 fi
 
+if test x"$with_gtk4" == xyes; then
+	PKG_CHECK_MODULES(GTK4, gtk4 >= 4.0)
+	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_4_0"
+	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MAX_ALLOWED=GDK_VERSION_4_0"
+	PKG_CHECK_MODULES(LIBNMA_GTK4, libnma-gtk4 >= 1.8.33)
+fi
+
 PKG_CHECK_MODULES(LIBNM, libnm >= 1.1.0)
-LIBNM_CFLAGS="$LIBNM_CFLAGS -DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_26"
-LIBNM_CFLAGS="$LIBNM_CFLAGS -DGLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_26"
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MIN_REQUIRED=NM_VERSION_1_2"
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MAX_ALLOWED=NM_VERSION_1_2"
 
@@ -118,9 +132,6 @@ fi
 
 AC_CONFIG_FILES([
 Makefile
-src/Makefile
-properties/Makefile
-auth-dialog/Makefile
 po/Makefile.in
 ])
 AC_OUTPUT
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 00b98b0..157d7a2 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -4,6 +4,9 @@ appdata/network-manager-ssh.metainfo.xml.in
 nm-ssh.desktop.in
 auth-dialog/main.c
 properties/advanced-dialog.c
-properties/nm-ssh.c
+properties/nm-ssh-editor-plugin.c
+properties/nm-ssh-editor.c
 [type: gettext/glade]properties/nm-ssh-dialog.ui
+shared/nm-utils/nm-shared-utils.c
+shared/nm-utils/nm-vpn-plugin-utils.c
 src/nm-ssh-service.c
diff --git a/po/POTFILES.skip b/po/POTFILES.skip
new file mode 100644
index 0000000..10b3933
--- /dev/null
+++ b/po/POTFILES.skip
@@ -0,0 +1 @@
+gtk4/nm-ssh-dialog.ui
diff --git a/properties/Makefile.am b/properties/Makefile.am
deleted file mode 100644
index e539652..0000000
--- a/properties/Makefile.am
+++ /dev/null
@@ -1,55 +0,0 @@
-SUBDIRS = .
-
-plugindir = $(libdir)/NetworkManager
-plugin_LTLIBRARIES = libnm-vpn-plugin-ssh.la
-if WITH_LIBNM_GLIB
-plugin_LTLIBRARIES += libnm-ssh-properties.la
-endif
-
-libnm_vpn_plugin_ssh_la_SOURCES = \
-	nm-ssh.c \
-	nm-ssh.h \
-	advanced-dialog.c \
-	advanced-dialog.h
-
-libnm_ssh_properties_la_SOURCES = \
-        $(libnm_vpn_plugin_ssh_la_SOURCES)
-
-uidir = $(datadir)/gnome-vpn-properties/ssh
-ui_DATA = nm-ssh-dialog.ui
-
-common_CFLAGS = \
-        $(GTK_CFLAGS) \
-        $(GNOMEKEYRING_CFLAGS) \
-        -I$(top_srcdir)/ \
-        -DICONDIR=\""$(datadir)/pixmaps"\" \
-        -DUIDIR=\""$(uidir)"\" \
-        -DGNOMELOCALEDIR=\"$(datadir)/locale\"
-
-libnm_vpn_plugin_ssh_la_CFLAGS = \
-        $(common_CFLAGS) \
-        $(LIBNM_CFLAGS)
-
-libnm_ssh_properties_la_CFLAGS = \
-        -DNM_SSH_OLD \
-        $(common_CFLAGS) \
-        $(LIBNM_GLIB_CFLAGS)
-
-libnm_vpn_plugin_ssh_la_LIBADD = \
-        $(GTK_LIBS) \
-        $(LIBNM_LIBS)
-
-libnm_ssh_properties_la_LIBADD = \
-        $(GTK_LIBS) \
-        $(LIBNM_GLIB_LIBS)
-
-libnm_vpn_plugin_ssh_la_LDFLAGS = \
-        -avoid-version
-
-libnm_ssh_properties_la_LDFLAGS = \
-        $(libnm_vpn_plugin_ssh_la_LDFLAGS)
-
-CLEANFILES = *.bak *~
-
-EXTRA_DIST = \
-        $(ui_DATA)
diff --git a/properties/advanced-dialog.c b/properties/advanced-dialog.c
index 7ca4a45..aa0705d 100644
--- a/properties/advanced-dialog.c
+++ b/properties/advanced-dialog.c
@@ -2,6 +2,7 @@
 /***************************************************************************
  *
  * Copyright (C) 2013 Dan Fruehauf, <malkodan@gmail.com>
+ * Copyright (C) 2022 Red Hat, Inc.
  * Based on work by Dan Williams, <dcbw@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -45,8 +46,8 @@
 #endif
 
 #include "advanced-dialog.h"
-#include "nm-ssh.h"
-#include "src/nm-ssh-service-defines.h"
+#include "nm-ssh-editor.h"
+#include "nm-service-defines.h"
 
 static const char *advanced_keys[] = {
 	NM_SSH_KEY_PORT,
@@ -93,7 +94,7 @@ port_toggled_cb (GtkWidget *check, gpointer user_data)
 	GtkWidget *widget;
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "port_spinbutton"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 }
 
 static void
@@ -103,7 +104,7 @@ tunmtu_toggled_cb (GtkWidget *check, gpointer user_data)
 	GtkWidget *widget;
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "tunmtu_spinbutton"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 }
 
 static void
@@ -113,7 +114,7 @@ remote_dev_toggled_cb (GtkWidget *check, gpointer user_data)
 	GtkWidget *widget;
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_dev_spinbutton"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 }
 
 static void
@@ -122,22 +123,12 @@ remote_username_toggled_cb (GtkWidget *check, gpointer user_data)
 	GtkBuilder *builder = (GtkBuilder *) user_data;
 	GtkWidget *widget;
 
-	/* Add a warning if not using root */
-	if (gtk_toggle_button_get_active  (GTK_TOGGLE_BUTTON (check) )) {
-		GtkWidget *dialog;
-		dialog = gtk_message_dialog_new(
-			GTK_WINDOW (gtk_builder_get_object (builder, "ssh_advanced_dialog")),
-			GTK_DIALOG_MODAL,
-			GTK_MESSAGE_WARNING,
-			GTK_BUTTONS_OK,
-			_("You have chosen not to use 'root' as the remote username.\n\nPlease make sure the user you specify is allowed to open tun/tap devices on the remote host."));
-		gtk_window_set_title(GTK_WINDOW(dialog), "Warning");
-		gtk_dialog_run(GTK_DIALOG(dialog));
-		gtk_widget_destroy(dialog);
-	}
+	widget = GTK_WIDGET (gtk_builder_get_object (builder, "user_warning_revealer"));
+	gtk_revealer_set_reveal_child (GTK_REVEALER (widget),
+		gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_entry"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 }
 
 GtkWidget *
@@ -145,7 +136,6 @@ advanced_dialog_new (GHashTable *hash)
 {
 	GtkBuilder *builder;
 	GtkWidget *dialog = NULL;
-	char *ui_file = NULL;
 	GtkWidget *widget;
 	const char *value;
 	GError *error = NULL;
@@ -153,12 +143,11 @@ advanced_dialog_new (GHashTable *hash)
 
 	g_return_val_if_fail (hash != NULL, NULL);
 
-	ui_file = g_strdup_printf ("%s/%s", UIDIR, "nm-ssh-dialog.ui");
 	builder = gtk_builder_new ();
 
 	gtk_builder_set_translation_domain (builder, GETTEXT_PACKAGE);
 
-	if (!gtk_builder_add_from_file (builder, ui_file, &error)) {
+	if (!gtk_builder_add_from_resource (builder, "/org/freedesktop/network-manager-ssh/nm-ssh-dialog.ui", &error)) {
 		g_warning ("Couldn't load builder file: %s", error->message);
 		g_error_free (error);
 		g_object_unref (G_OBJECT (builder));
@@ -184,7 +173,7 @@ advanced_dialog_new (GHashTable *hash)
 		errno = 0;
 		tmp = strtol (value, NULL, 10);
 		if (errno == 0 && tmp > 0 && tmp < 65536) {
-			gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+			gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 
 			widget = GTK_WIDGET (gtk_builder_get_object (builder, "port_spinbutton"));
 			gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget),
@@ -192,7 +181,7 @@ advanced_dialog_new (GHashTable *hash)
 		}
 		gtk_widget_set_sensitive (widget, TRUE);
 	} else {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), FALSE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), FALSE);
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "port_spinbutton"));
 		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble) NM_SSH_DEFAULT_PORT);
@@ -208,14 +197,14 @@ advanced_dialog_new (GHashTable *hash)
 		errno = 0;
 		tmp = strtol (value, NULL, 10);
 		if (errno == 0 && tmp > 0 && tmp < 65536) {
-			gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+			gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 
 			widget = GTK_WIDGET (gtk_builder_get_object (builder, "tunmtu_spinbutton"));
 			gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble) tmp);
 			gtk_widget_set_sensitive (widget, TRUE);
 		}
 	} else {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), FALSE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), FALSE);
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "tunmtu_spinbutton"));
 		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble) NM_SSH_DEFAULT_MTU);
@@ -231,14 +220,14 @@ advanced_dialog_new (GHashTable *hash)
 		errno = 0;
 		tmp = strtol (value, NULL, 10);
 		if (errno == 0 && tmp >= 0 && tmp < 256) {
-			gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+			gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 
 			widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_dev_spinbutton"));
 			gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble) tmp);
 		}
 		gtk_widget_set_sensitive (widget, TRUE);
 	} else {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), FALSE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), FALSE);
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_dev_spinbutton"));
 		gtk_spin_button_set_value (GTK_SPIN_BUTTON (widget), (gdouble) NM_SSH_DEFAULT_REMOTE_DEV);
@@ -248,7 +237,7 @@ advanced_dialog_new (GHashTable *hash)
 	value = g_hash_table_lookup (hash, NM_SSH_KEY_TAP_DEV);
 	if (value && IS_YES(value)) {
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "tap_checkbutton"));
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_checkbutton"));
@@ -257,21 +246,20 @@ advanced_dialog_new (GHashTable *hash)
 
 	value = g_hash_table_lookup (hash, NM_SSH_KEY_REMOTE_USERNAME);
 	if (value && strlen (value)) {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_entry"));
-		gtk_entry_set_text (GTK_ENTRY (widget), value);
+		gtk_editable_set_text (GTK_EDITABLE (widget), value);
 		gtk_widget_set_sensitive (widget, TRUE);
 	} else {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), FALSE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), FALSE);
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_entry"));
-		gtk_entry_set_text (GTK_ENTRY (widget), NM_SSH_DEFAULT_REMOTE_USERNAME);
+		gtk_editable_set_text (GTK_EDITABLE (widget), NM_SSH_DEFAULT_REMOTE_USERNAME);
 		gtk_widget_set_sensitive (widget, FALSE);
 	}
 
 out:
-	g_free (ui_file);
 	return dialog;
 }
 
@@ -292,7 +280,7 @@ advanced_dialog_new_hash_from_dialog (GtkWidget *dialog, GError **error)
 	hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "tunmtu_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget))) {
 		int tunmtu_size;
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "tunmtu_spinbutton"));
@@ -301,7 +289,7 @@ advanced_dialog_new_hash_from_dialog (GtkWidget *dialog, GError **error)
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "port_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget))) {
 		int port;
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "port_spinbutton"));
@@ -310,7 +298,7 @@ advanced_dialog_new_hash_from_dialog (GtkWidget *dialog, GError **error)
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_dev_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget))) {
 		int remote_dev;
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_dev_spinbutton"));
@@ -319,15 +307,15 @@ advanced_dialog_new_hash_from_dialog (GtkWidget *dialog, GError **error)
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "tap_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget)))
 		g_hash_table_insert (hash, g_strdup (NM_SSH_KEY_TAP_DEV), g_strdup (YES));
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget))) {
 		const gchar *remote_username;
 
 		widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_username_entry"));
-		remote_username = gtk_entry_get_text (GTK_ENTRY (widget));
+		remote_username = gtk_editable_get_text (GTK_EDITABLE (widget));
 		g_hash_table_insert (hash, g_strdup (NM_SSH_KEY_REMOTE_USERNAME), g_strdup(remote_username));
 	}
 
diff --git a/properties/gresource.xml b/properties/gresource.xml
new file mode 100644
index 0000000..1a4e1df
--- /dev/null
+++ b/properties/gresource.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<gresources>
+	<gresource prefix="/org/freedesktop/network-manager-ssh">
+		<file preprocess="xml-stripblanks">nm-ssh-dialog.ui</file>
+	</gresource>
+</gresources>
diff --git a/properties/nm-ssh-dialog.ui b/properties/nm-ssh-dialog.ui
index 511a93f..d54b92e 100644
--- a/properties/nm-ssh-dialog.ui
+++ b/properties/nm-ssh-dialog.ui
@@ -90,31 +90,22 @@
     </data>
   </object>
   <object class="GtkDialog" id="ssh_advanced_dialog">
-    <property name="can_focus">False</property>
-    <property name="border_width">5</property>
     <property name="title" translatable="yes">SSH Advanced Options</property>
-    <property name="window_position">center-on-parent</property>
     <property name="destroy_with_parent">True</property>
     <property name="icon_name">stock-preferences</property>
-    <property name="type_hint">dialog</property>
-    <property name="skip_pager_hint">True</property>
     <child internal-child="vbox">
       <object class="GtkVBox" id="ssh_advanced_dialog_vbox">
         <property name="visible">True</property>
-        <property name="can_focus">False</property>
         <property name="spacing">2</property>
         <child internal-child="action_area">
-          <object class="GtkHButtonBox" id="ssh_advanced_dialog_action_area">
+          <object class="GtkBox" id="ssh_advanced_dialog_action_area">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="layout_style">end</property>
             <child>
               <object class="GtkButton" id="cancel_button">
-                <property name="label">gtk-cancel</property>
+                <property name="label" translatable="yes">_Cancel</property>
+                <property name="use-underline">True</property>
                 <property name="visible">True</property>
-                <property name="can_focus">True</property>
                 <property name="receives_default">False</property>
-                <property name="use_stock">True</property>
               </object>
               <packing>
                 <property name="expand">False</property>
@@ -124,11 +115,10 @@
             </child>
             <child>
               <object class="GtkButton" id="ok_button">
-                <property name="label">gtk-ok</property>
+                <property name="label" translatable="yes">_Apply</property>
+                <property name="use-underline">True</property>
                 <property name="visible">True</property>
-                <property name="can_focus">True</property>
                 <property name="receives_default">False</property>
-                <property name="use_stock">True</property>
               </object>
               <packing>
                 <property name="expand">False</property>
@@ -144,26 +134,46 @@
             <property name="position">0</property>
           </packing>
         </child>
+        <child>
+          <object class="GtkRevealer" id="user_warning_revealer">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <child>
+              <object class="GtkInfoBar" id="error_bar">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkLabel" id="error_label">
+                    <property name="visible">True</property>
+                    <property name="can_focus">False</property>
+                    <property name="label" translatable="yes">You have chosen not to use 'root' as the remote username.
+
+Please make sure the user you specify is allowed to open tun/tap devices on the remote host.</property>
+                  </object>
+                </child>
+              </object>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">True</property>
+            <property name="position">1</property>
+          </packing>
+        </child>
         <child>
           <object class="GtkNotebook" id="advanced_dialog_notebook">
             <property name="visible">True</property>
-            <property name="can_focus">True</property>
             <child>
               <object class="GtkVBox" id="advanced_dialog_vbox">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="border_width">12</property>
                 <property name="spacing">6</property>
                 <child>
                   <object class="GtkHBox" id="port_hbox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="spacing">6</property>
                     <child>
                       <object class="GtkCheckButton" id="port_checkbutton">
                         <property name="label" translatable="yes">Use custom gateway port:</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="receives_default">False</property>
                         <property name="use_underline">True</property>
                         <property name="draw_indicator">True</property>
@@ -177,11 +187,6 @@
                     <child>
                       <object class="GtkSpinButton" id="port_spinbutton">
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
                         <property name="adjustment">adjustment1</property>
                         <property name="climb_rate">1</property>
                         <property name="numeric">True</property>
@@ -202,13 +207,11 @@
                 <child>
                   <object class="GtkHBox" id="tunmtu_hbox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="spacing">6</property>
                     <child>
                       <object class="GtkCheckButton" id="tunmtu_checkbutton">
                         <property name="label" translatable="yes">Use custom tunnel Maximum Transmission Unit (MTU):</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="receives_default">False</property>
                         <property name="use_underline">True</property>
                         <property name="draw_indicator">True</property>
@@ -222,13 +225,6 @@
                     <child>
                       <object class="GtkSpinButton" id="tunmtu_spinbutton">
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="invisible_char">●</property>
-                        <property name="invisible_char_set">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
                         <property name="adjustment">adjustment2</property>
                         <property name="climb_rate">1</property>
                         <property name="numeric">True</property>
@@ -249,16 +245,13 @@
                 <child>
                   <object class="GtkHBox" id="remote_dev_hbox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="spacing">6</property>
                     <child>
                       <object class="GtkCheckButton" id="remote_dev_checkbutton">
                         <property name="label" translatable="yes">Remote device number:</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="receives_default">False</property>
                         <property name="use_underline">True</property>
-                        <property name="yalign">0.49000000953674316</property>
                         <property name="draw_indicator">True</property>
                       </object>
                       <packing>
@@ -270,14 +263,6 @@
                     <child>
                       <object class="GtkSpinButton" id="remote_dev_spinbutton">
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="max_length">5</property>
-                        <property name="invisible_char">●</property>
-                        <property name="invisible_char_set">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
                         <property name="adjustment">adjustment3</property>
                         <property name="climb_rate">1</property>
                         <property name="numeric">True</property>
@@ -298,16 +283,13 @@
                 <child>
                   <object class="GtkHBox" id="tap_hbox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="spacing">6</property>
                     <child>
                       <object class="GtkCheckButton" id="tap_checkbutton">
                         <property name="label" translatable="yes">Use a TAP device</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="receives_default">False</property>
                         <property name="use_underline">True</property>
-                        <property name="yalign">0.49000000953674316</property>
                         <property name="draw_indicator">True</property>
                       </object>
                       <packing>
@@ -326,16 +308,13 @@
                 <child>
                   <object class="GtkHBox" id="remote_username_hbox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="spacing">6</property>
                     <child>
                       <object class="GtkCheckButton" id="remote_username_checkbutton">
                         <property name="label" translatable="yes">Remote username:</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="receives_default">False</property>
                         <property name="use_underline">True</property>
-                        <property name="yalign">0.52999997138977051</property>
                         <property name="draw_indicator">True</property>
                       </object>
                       <packing>
@@ -347,14 +326,9 @@
                     <child>
                       <object class="GtkEntry" id="remote_username_entry">
                         <property name="visible">True</property>
-                        <property name="can_focus">True</property>
                         <property name="invisible_char">●</property>
                         <property name="text">root</property>
                         <property name="invisible_char_set">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
                       </object>
                       <packing>
                         <property name="expand">True</property>
@@ -374,7 +348,6 @@
             <child type="tab">
               <object class="GtkLabel" id="advanced_dialog_label">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="label" translatable="yes">General</property>
               </object>
               <packing>
@@ -385,7 +358,7 @@
           <packing>
             <property name="expand">False</property>
             <property name="fill">False</property>
-            <property name="position">1</property>
+            <property name="position">2</property>
           </packing>
         </child>
       </object>
@@ -397,21 +370,20 @@
   </object>
   <object class="GtkVBox" id="ssh_main_vbox">
     <property name="visible">True</property>
-    <property name="can_focus">False</property>
-    <property name="border_width">12</property>
     <property name="spacing">16</property>
     <child>
       <object class="GtkVBox" id="general_vbox">
         <property name="visible">True</property>
-        <property name="can_focus">False</property>
         <property name="spacing">6</property>
         <child>
           <object class="GtkLabel" id="general_label">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
             <property name="xalign">0</property>
-            <property name="label" translatable="yes">&lt;b&gt;General&lt;/b&gt;</property>
-            <property name="use_markup">True</property>
+            <property name="label" translatable="yes">General</property>
+            <property name="margin_bottom">6</property>
+            <attributes>
+              <attribute name="weight" value="bold"/>
+            </attributes>
           </object>
           <packing>
             <property name="expand">False</property>
@@ -420,82 +392,57 @@
           </packing>
         </child>
         <child>
-          <object class="GtkAlignment" id="general_alignment">
+          <object class="GtkGrid" id="general_table">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="left_padding">12</property>
+            <property name="column_spacing">6</property>
+            <property name="row_spacing">6</property>
             <child>
-              <object class="GtkTable" id="general_table">
+              <object class="GtkLabel" id="gateway_label">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="n_columns">2</property>
-                <property name="column_spacing">6</property>
-                <property name="row_spacing">6</property>
-                <child>
-                  <object class="GtkLabel" id="gateway_label">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">0</property>
-                    <property name="label" translatable="yes">Gateway:</property>
-                    <property name="use_underline">True</property>
-                    <property name="mnemonic_widget">gateway_entry</property>
-                  </object>
-                  <packing>
-                    <property name="x_options"/>
-                    <property name="y_options"/>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkAlignment" id="gateway_alignment">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">1</property>
-                    <property name="xscale">0</property>
-                    <child>
-                      <object class="GtkEntry" id="gateway_entry">
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
-                      </object>
-                    </child>
-                  </object>
-                  <packing>
-                    <property name="left_attach">1</property>
-                    <property name="right_attach">2</property>
-                    <property name="y_options"/>
-                  </packing>
-                </child>
+                <property name="xalign">1</property>
+                <property name="label" translatable="yes">Gateway</property>
+                <property name="use_underline">True</property>
+                <property name="mnemonic_widget">gateway_entry</property>
               </object>
+              <packing>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkEntry" id="gateway_entry">
+                <property name="visible">True</property>
+              </object>
+              <packing>
+                <property name="left_attach">1</property>
+              </packing>
             </child>
           </object>
           <packing>
-            <property name="expand">True</property>
-            <property name="fill">True</property>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
             <property name="position">1</property>
           </packing>
         </child>
       </object>
       <packing>
         <property name="expand">False</property>
-        <property name="fill">True</property>
+        <property name="fill">False</property>
         <property name="position">0</property>
       </packing>
     </child>
     <child>
       <object class="GtkVBox" id="network_settings_vbox">
         <property name="visible">True</property>
-        <property name="can_focus">False</property>
         <property name="spacing">6</property>
         <child>
           <object class="GtkLabel" id="network_settings_label">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
             <property name="xalign">0</property>
-            <property name="label" translatable="yes">&lt;b&gt;Network Settings&lt;/b&gt;</property>
-            <property name="use_markup">True</property>
+            <property name="label" translatable="yes">Network Settings</property>
+            <property name="margin_top">12</property>
+            <property name="margin_bottom">6</property>
+            <attributes>
+              <attribute name="weight" value="bold"/>
+            </attributes>
           </object>
           <packing>
             <property name="expand">False</property>
@@ -504,156 +451,91 @@
           </packing>
         </child>
         <child>
-          <object class="GtkAlignment" id="network_settings_alignment">
+          <object class="GtkGrid" id="network_settings_table">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="left_padding">12</property>
+            <property name="column_spacing">6</property>
+            <property name="row_spacing">6</property>
             <child>
-              <object class="GtkTable" id="network_settings_table">
+              <object class="GtkNotebook" id="network_settings_notebook">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="n_columns">2</property>
-                <property name="column_spacing">6</property>
-                <property name="row_spacing">6</property>
+                <property name="show_tabs">False</property>
+                <property name="show_border">False</property>
                 <child>
-                  <object class="GtkNotebook" id="network_settings_notebook">
+                  <object class="GtkGrid" id="network_settings_notebook_table">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="show_tabs">False</property>
-                    <property name="show_border">False</property>
+                    <property name="column_spacing">6</property>
+                    <property name="row_spacing">6</property>
                     <child>
-                      <object class="GtkTable" id="network_settings_notebook_table">
+                      <object class="GtkLabel" id="remote_ip_label">
                         <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="n_rows">3</property>
-                        <property name="n_columns">2</property>
-                        <property name="column_spacing">6</property>
-                        <property name="row_spacing">6</property>
-                        <child>
-                          <object class="GtkLabel" id="remote_ip_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Remote IP Address:</property>
-                            <property name="justify">right</property>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="remote_ip_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="remote_ip_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="text">172.16.40.1</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="local_ip_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Local IP Address:</property>
-                            <property name="justify">right</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="local_ip_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="local_ip_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="text">172.16.40.2</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="netmask_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Netmask:</property>
-                            <property name="justify">right</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="netmask_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="netmask_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="invisible_char">●</property>
-                                <property name="text">255.255.255.252</property>
-                                <property name="invisible_char_set">True</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Remote IP Address</property>
+                        <property name="justify">right</property>
                       </object>
                     </child>
-                    <child type="tab">
-                      <placeholder/>
+                    <child>
+                      <object class="GtkEntry" id="remote_ip_entry">
+                        <property name="visible">True</property>
+                        <property name="text">172.16.40.1</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="local_ip_label">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Local IP Address</property>
+                        <property name="justify">right</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">0</property>
+                        <property name="top_attach">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="local_ip_entry">
+                        <property name="visible">True</property>
+                        <property name="text">172.16.40.2</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                        <property name="top_attach">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="netmask_label">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Netmask</property>
+                        <property name="justify">right</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">0</property>
+                        <property name="top_attach">2</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="netmask_entry">
+                        <property name="visible">True</property>
+                        <property name="invisible_char">●</property>
+                        <property name="text">255.255.255.252</property>
+                        <property name="invisible_char_set">True</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                        <property name="top_attach">2</property>
+                      </packing>
                     </child>
                   </object>
-                  <packing>
-                    <property name="right_attach">2</property>
-                    <property name="y_options">GTK_EXPAND</property>
-                  </packing>
+                </child>
+                <child type="tab">
+                  <placeholder/>
                 </child>
               </object>
+              <packing>
+              </packing>
             </child>
           </object>
           <packing>
@@ -664,11 +546,13 @@
         </child>
         <child>
           <object class="GtkLabel" id="ipv6_label">
-            <property name="can_focus">False</property>
-            <property name="no_show_all">True</property>
             <property name="xalign">0</property>
-            <property name="label" translatable="yes">&lt;b&gt;IPv6 Network Settings&lt;/b&gt;</property>
-            <property name="use_markup">True</property>
+            <property name="label" translatable="yes">IPv6 Network Settings</property>
+            <property name="margin_top">12</property>
+            <property name="margin_bottom">6</property>
+            <attributes>
+              <attribute name="weight" value="bold"/>
+            </attributes>
           </object>
           <packing>
             <property name="expand">False</property>
@@ -677,180 +561,111 @@
           </packing>
         </child>
         <child>
-          <object class="GtkAlignment" id="ipv6_alignment">
-            <property name="can_focus">False</property>
-            <property name="no_show_all">True</property>
-            <property name="left_padding">12</property>
+          <object class="GtkGrid" id="ipv6_table">
+            <property name="visible">True</property>
+            <property name="column_spacing">6</property>
+            <property name="row_spacing">6</property>
             <child>
-              <object class="GtkTable" id="ipv6_table">
+              <object class="GtkNotebook" id="ipv6_notebook">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="n_columns">2</property>
-                <property name="column_spacing">6</property>
-                <property name="row_spacing">6</property>
+                <property name="show_tabs">False</property>
+                <property name="show_border">False</property>
                 <child>
-                  <object class="GtkNotebook" id="ipv6_notebook">
+                  <object class="GtkGrid" id="ipv6_notebook_table">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="show_tabs">False</property>
-                    <property name="show_border">False</property>
+                    <property name="column_spacing">6</property>
+                    <property name="row_spacing">6</property>
                     <child>
-                      <object class="GtkTable" id="ipv6_notebook_table">
+                      <object class="GtkCheckButton" id="ipv6_checkbutton">
+                        <property name="label" translatable="yes">Use IPv6</property>
                         <property name="visible">True</property>
-                        <property name="can_focus">False</property>
-                        <property name="n_rows">4</property>
-                        <property name="n_columns">2</property>
-                        <property name="column_spacing">6</property>
-                        <property name="row_spacing">6</property>
-                        <child>
-                          <object class="GtkCheckButton" id="ipv6_checkbutton">
-                            <property name="label" translatable="yes">Use IPv6</property>
-                            <property name="visible">True</property>
-                            <property name="can_focus">True</property>
-                            <property name="receives_default">False</property>
-                            <property name="use_underline">True</property>
-                            <property name="yalign">0.49000000953674316</property>
-                            <property name="draw_indicator">True</property>
-                          </object>
-                          <packing>
-                            <property name="right_attach">2</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="remote_ip_6_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Remote IP Address (IPv6):</property>
-                            <property name="justify">right</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="remote_ip_6_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="remote_ip_6_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="invisible_char">●</property>
-                                <property name="text">2001:db8:abba:1000::1</property>
-                                <property name="invisible_char_set">True</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">1</property>
-                            <property name="bottom_attach">2</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="local_ip_6_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Local IP Address (IPv6):</property>
-                            <property name="justify">right</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="local_ip_6_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="local_ip_6_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="invisible_char">●</property>
-                                <property name="text">2001:db8:abba:1000::2</property>
-                                <property name="invisible_char_set">True</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">2</property>
-                            <property name="bottom_attach">3</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="netmask_6_label">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">0</property>
-                            <property name="label" translatable="yes">Prefix (IPv6):</property>
-                            <property name="justify">right</property>
-                          </object>
-                          <packing>
-                            <property name="top_attach">3</property>
-                            <property name="bottom_attach">4</property>
-                          </packing>
-                        </child>
-                        <child>
-                          <object class="GtkAlignment" id="netmask_6_alignment">
-                            <property name="visible">True</property>
-                            <property name="can_focus">False</property>
-                            <property name="xalign">1</property>
-                            <property name="xscale">0</property>
-                            <child>
-                              <object class="GtkEntry" id="netmask_6_entry">
-                                <property name="visible">True</property>
-                                <property name="can_focus">True</property>
-                                <property name="invisible_char">●</property>
-                                <property name="text">64</property>
-                                <property name="invisible_char_set">True</property>
-                                <property name="primary_icon_activatable">False</property>
-                                <property name="secondary_icon_activatable">False</property>
-                                <property name="primary_icon_sensitive">True</property>
-                                <property name="secondary_icon_sensitive">True</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="left_attach">1</property>
-                            <property name="right_attach">2</property>
-                            <property name="top_attach">3</property>
-                            <property name="bottom_attach">4</property>
-                            <property name="y_options"/>
-                          </packing>
-                        </child>
+                        <property name="receives_default">False</property>
+                        <property name="use_underline">True</property>
+                        <property name="draw_indicator">True</property>
                       </object>
+                      <packing>
+                      </packing>
                     </child>
-                    <child type="tab">
-                      <placeholder/>
+                    <child>
+                      <object class="GtkLabel" id="remote_ip_6_label">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Remote IP Address (IPv6)</property>
+                        <property name="justify">right</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">0</property>
+                        <property name="top_attach">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="remote_ip_6_entry">
+                        <property name="visible">True</property>
+                        <property name="invisible_char">●</property>
+                        <property name="text">2001:db8:abba:1000::1</property>
+                        <property name="invisible_char_set">True</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                        <property name="top_attach">1</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="local_ip_6_label">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Local IP Address (IPv6)</property>
+                        <property name="justify">right</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">0</property>
+                        <property name="top_attach">2</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="local_ip_6_entry">
+                        <property name="visible">True</property>
+                        <property name="invisible_char">●</property>
+                        <property name="text">2001:db8:abba:1000::2</property>
+                        <property name="invisible_char_set">True</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                        <property name="top_attach">2</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkLabel" id="netmask_6_label">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="label" translatable="yes">Prefix (IPv6)</property>
+                        <property name="justify">right</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">0</property>
+                        <property name="top_attach">3</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkEntry" id="netmask_6_entry">
+                        <property name="visible">True</property>
+                        <property name="invisible_char">●</property>
+                        <property name="text">64</property>
+                        <property name="invisible_char_set">True</property>
+                      </object>
+                      <packing>
+                        <property name="left_attach">1</property>
+                        <property name="top_attach">3</property>
+                      </packing>
                     </child>
                   </object>
-                  <packing>
-                    <property name="right_attach">2</property>
-                    <property name="y_options">GTK_EXPAND</property>
-                  </packing>
+                </child>
+                <child type="tab">
+                  <placeholder/>
                 </child>
               </object>
+              <packing>
+              </packing>
             </child>
           </object>
           <packing>
@@ -866,72 +681,20 @@
         <property name="position">1</property>
       </packing>
     </child>
-    <child>
-      <object class="GtkAlignment" id="ssh_main_vbox_advanced_alignment">
-        <property name="visible">True</property>
-        <property name="can_focus">False</property>
-        <property name="xalign">1</property>
-        <property name="xscale">0</property>
-        <child>
-          <object class="GtkButton" id="advanced_button">
-            <property name="visible">True</property>
-            <property name="can_focus">True</property>
-            <property name="receives_default">False</property>
-            <child>
-              <object class="GtkHBox" id="advanced_button_hbox">
-                <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="spacing">6</property>
-                <child>
-                  <object class="GtkImage" id="advanced_button_image">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="stock">gtk-preferences</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">False</property>
-                    <property name="position">0</property>
-                  </packing>
-                </child>
-                <child>
-                  <object class="GtkLabel" id="advanced_button_label">
-                    <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="label" translatable="yes">Advanced...</property>
-                    <property name="use_markup">True</property>
-                    <property name="use_underline">True</property>
-                  </object>
-                  <packing>
-                    <property name="expand">False</property>
-                    <property name="fill">False</property>
-                    <property name="position">1</property>
-                  </packing>
-                </child>
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-      <packing>
-        <property name="expand">False</property>
-        <property name="fill">False</property>
-        <property name="pack_type">end</property>
-        <property name="position">2</property>
-      </packing>
-    </child>
     <child>
       <object class="GtkVBox" id="auth_vbox">
         <property name="visible">True</property>
-        <property name="can_focus">False</property>
         <property name="spacing">6</property>
         <child>
           <object class="GtkLabel" id="auth_label">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
             <property name="xalign">0</property>
-            <property name="label" translatable="yes">&lt;b&gt;Authentication&lt;/b&gt;</property>
-            <property name="use_markup">True</property>
+            <property name="label" translatable="yes">Authentication</property>
+            <property name="margin_top">12</property>
+            <property name="margin_bottom">6</property>
+            <attributes>
+              <attribute name="weight" value="bold"/>
+            </attributes>
           </object>
           <packing>
             <property name="expand">False</property>
@@ -940,23 +703,23 @@
           </packing>
         </child>
         <child>
-          <object class="GtkTable" id="auth_auth_type_table">
+          <object class="GtkGrid" id="auth_auth_type_table">
             <property name="visible">True</property>
-            <property name="can_focus">False</property>
-            <property name="n_columns">2</property>
+            <property name="column_spacing">6</property>
+            <property name="row_spacing">6</property>
             <child>
               <object class="GtkLabel" id="auth_auth_type_label">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="xalign">0</property>
-                <property name="label" translatable="yes">Type:</property>
-                <property name="use_markup">True</property>
+                <property name="xalign">1</property>
+                <property name="label" translatable="yes">Type</property>
               </object>
+              <packing>
+                <property name="left_attach">0</property>
+              </packing>
             </child>
             <child>
               <object class="GtkComboBox" id="auth_auth_type_combobox">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="tooltip_text" translatable="yes">Select an authentication mode.</property>
                 <property name="model">model2</property>
                 <child>
@@ -968,7 +731,6 @@
               </object>
               <packing>
                 <property name="left_attach">1</property>
-                <property name="right_attach">2</property>
               </packing>
             </child>
           </object>
@@ -981,13 +743,11 @@
         <child>
           <object class="GtkNotebook" id="auth_notebook">
             <property name="visible">True</property>
-            <property name="can_focus">True</property>
             <property name="show_tabs">False</property>
             <property name="show_border">False</property>
             <child>
-              <object class="GtkTable" id="auth_ssh_agent_table">
+              <object class="GtkGrid" id="auth_ssh_agent_table">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="column_spacing">6</property>
                 <property name="row_spacing">6</property>
                 <child>
@@ -1019,7 +779,6 @@
             <child type="tab">
               <object class="GtkLabel" id="auth_notebook_label1">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="label">page 1</property>
               </object>
               <packing>
@@ -1027,71 +786,47 @@
               </packing>
             </child>
             <child>
-              <object class="GtkTable" id="auth_password_table">
+              <object class="GtkGrid" id="auth_password_table">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="n_rows">2</property>
-                <property name="n_columns">2</property>
                 <property name="column_spacing">6</property>
                 <property name="row_spacing">6</property>
                 <child>
                   <object class="GtkLabel" id="auth_password_label">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">0</property>
-                    <property name="label" translatable="yes">Password:</property>
+                    <property name="xalign">1</property>
+                    <property name="label" translatable="yes">Password</property>
                     <property name="use_underline">True</property>
                     <property name="mnemonic_widget">gateway_entry</property>
                   </object>
                   <packing>
-                    <property name="x_options">GTK_FILL</property>
-                    <property name="y_options"/>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkAlignment" id="auth_password_alignment">
+                  <object class="GtkEntry" id="auth_password_entry">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">1</property>
-                    <property name="xscale">0</property>
-                    <child>
-                      <object class="GtkEntry" id="auth_password_entry">
-                        <property name="visible">True</property>
-                        <property name="can_focus">True</property>
-                        <property name="invisible_char">●</property>
-                        <property name="invisible_char_set">True</property>
-                        <property name="primary_icon_activatable">False</property>
-                        <property name="secondary_icon_activatable">False</property>
-                        <property name="primary_icon_sensitive">True</property>
-                        <property name="secondary_icon_sensitive">True</property>
-                      </object>
-                    </child>
+                    <property name="invisible_char">●</property>
+                    <property name="invisible_char_set">True</property>
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
-                    <property name="right_attach">2</property>
-                    <property name="y_options"/>
                   </packing>
                 </child>
                 <child>
                   <object class="GtkCheckButton" id="auth_password_show_password_checkbutton">
                     <property name="label" translatable="yes">Show Passwords</property>
                     <property name="visible">True</property>
-                    <property name="can_focus">True</property>
                     <property name="receives_default">False</property>
                     <property name="use_underline">True</property>
-                    <property name="yalign">0.49000000953674316</property>
                     <property name="draw_indicator">True</property>
                   </object>
                   <packing>
+                    <property name="left_attach">0</property>
                     <property name="top_attach">1</property>
-                    <property name="bottom_attach">2</property>
                   </packing>
                 </child>
                 <child>
                   <object class="GtkComboBox" id="auth_password_save_password_combobox">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
                     <property name="model">model2</property>
                     <child>
                       <object class="GtkCellRendererText" id="renderer1"/>
@@ -1102,9 +837,7 @@
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
-                    <property name="right_attach">2</property>
                     <property name="top_attach">1</property>
-                    <property name="bottom_attach">2</property>
                   </packing>
                 </child>
               </object>
@@ -1115,7 +848,6 @@
             <child type="tab">
               <object class="GtkLabel" id="auth_notebook_label2">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="label">page 2</property>
               </object>
               <packing>
@@ -1124,43 +856,61 @@
               </packing>
             </child>
             <child>
-              <object class="GtkTable" id="auth_keyfile_table">
+              <object class="GtkGrid" id="auth_keyfile_table">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
-                <property name="n_columns">2</property>
                 <property name="column_spacing">6</property>
                 <property name="row_spacing">6</property>
                 <child>
                   <object class="GtkLabel" id="auth_keyfile_label">
                     <property name="visible">True</property>
-                    <property name="can_focus">False</property>
-                    <property name="xalign">0</property>
-                    <property name="label" translatable="yes">SSH Key File:</property>
+                    <property name="xalign">1</property>
+                    <property name="label" translatable="yes">SSH Key File</property>
                     <property name="use_underline">True</property>
                     <property name="mnemonic_widget">gateway_entry</property>
                   </object>
                   <packing>
-                    <property name="x_options"/>
-                    <property name="y_options"/>
                   </packing>
                 </child>
                 <child>
-                  <object class="GtkAlignment" id="auth_keyfile_alignment">
+                  <object class="GtkButton" id="auth_keyfile_button">
                     <property name="visible">True</property>
                     <property name="can_focus">False</property>
-                    <property name="xalign">1</property>
-                    <property name="xscale">0</property>
+                    <property name="hexpand">True</property>
                     <child>
-                      <object class="GtkFileChooserButton" id="auth_keyfile_filechooserbutton">
+                      <object class="GtkBox">
                         <property name="visible">True</property>
-                        <property name="can_focus">False</property>
+                        <property name="can-focus">False</property>
+                        <child>
+                          <object class="GtkLabel" id="auth_keyfile_button_label">
+                            <property name="visible">True</property>
+                            <property name="can-focus">False</property>
+                            <property name="label" translatable="yes">(None)</property>
+                            <property name="use-underline">True</property>
+                            <property name="xalign">0</property>
+                          </object>
+                          <packing>
+                            <property name="expand">True</property>
+                            <property name="fill">True</property>
+                            <property name="position">0</property>
+                          </packing>
+                        </child>
+                        <child>
+                          <object class="GtkImage">
+                            <property name="visible">True</property>
+                            <property name="can-focus">False</property>
+                            <property name="icon-name">document-open-symbolic</property>
+                          </object>
+                          <packing>
+                            <property name="expand">False</property>
+                            <property name="fill">True</property>
+                            <property name="position">1</property>
+                          </packing>
+                        </child>
                       </object>
                     </child>
                   </object>
                   <packing>
                     <property name="left_attach">1</property>
-                    <property name="right_attach">2</property>
-                    <property name="y_options"/>
                   </packing>
                 </child>
               </object>
@@ -1171,7 +921,6 @@
             <child type="tab">
               <object class="GtkLabel" id="auth_notebook_label3">
                 <property name="visible">True</property>
-                <property name="can_focus">False</property>
                 <property name="label">page 3</property>
               </object>
               <packing>
@@ -1193,5 +942,111 @@
         <property name="position">3</property>
       </packing>
     </child>
+    <child>
+      <object class="GtkHBox">
+        <property name="visible">True</property>
+        <child>
+          <object class="GtkButton" id="advanced_button">
+            <property name="visible">True</property>
+            <property name="receives_default">False</property>
+            <child>
+              <object class="GtkHBox" id="advanced_button_hbox">
+                <property name="visible">True</property>
+                <property name="spacing">6</property>
+                <child>
+                  <object class="GtkImage" id="advanced_button_image">
+                    <property name="visible">True</property>
+                    <property name="icon_name">preferences-system-symbolic</property>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkLabel" id="advanced_button_label">
+                    <property name="visible">True</property>
+                    <property name="label" translatable="yes">Advanced...</property>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+              </object>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
+            <property name="pack_type">end</property>
+            <property name="position">2</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+  <object class="GtkFileChooserDialog" id="auth_keyfile_chooser">
+    <property name="modal">True</property>
+    <action-widgets>
+      <action-widget response="-6">auth_keyfile_chooser_cancel</action-widget>
+      <action-widget response="-3">auth_keyfile_chooser_accept</action-widget>
+    </action-widgets>
+    <child type="titlebar">
+      <object class="GtkHeaderBar">
+        <property name="visible">True</property>
+        <property name="show-close-button">False</property>
+        <child type="title">
+          <object class="GtkLabel">
+            <property name="visible">True</property>
+            <property name="label" translatable="yes">Choose a SSH private key…</property>
+            <style>
+              <class name="title"/>
+            </style>
+          </object>
+        </child>
+        <child>
+          <object class="GtkButton" id="auth_keyfile_chooser_cancel">
+            <property name="label" translatable="yes">_Cancel</property>
+            <property name="visible">True</property>
+            <property name="receives-default">False</property>
+            <property name="use-underline">True</property>
+          </object>
+        </child>
+        <child>
+          <object class="GtkButton" id="auth_keyfile_chooser_accept">
+            <property name="label" translatable="yes">_Select</property>
+            <property name="visible">True</property>
+            <property name="receives-default">True</property>
+            <property name="use-underline">True</property>
+            <property name="can-default">True</property>
+            <style>
+              <class name="default"/>
+              <class name="suggested-action"/>
+            </style>
+          </object>
+          <packing>
+            <property name="position">1</property>
+            <property name="pack-type">end</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+  <object class="GtkSizeGroup" id="labels">
+    <widgets>
+      <widget name="gateway_label"/>
+      <widget name="remote_ip_label"/>
+      <widget name="local_ip_label"/>
+      <widget name="netmask_label"/>
+      <widget name="remote_ip_6_label"/>
+      <widget name="local_ip_6_label"/>
+      <widget name="netmask_6_label"/>
+      <widget name="auth_auth_type_label"/>
+      <widget name="auth_password_label"/>
+      <widget name="auth_keyfile_label"/>
+    </widgets>
   </object>
 </interface>
diff --git a/properties/nm-ssh-editor-plugin.c b/properties/nm-ssh-editor-plugin.c
new file mode 100644
index 0000000..67c2e9f
--- /dev/null
+++ b/properties/nm-ssh-editor-plugin.c
@@ -0,0 +1,549 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ *
+ * Copyright (C) 2013 Dan Fruehauf, <malkodan@gmail.com>
+ * Copyright (C) 2022 Red Hat, Inc.
+ * Based on work by Dan Williams, <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#include "nm-default.h"
+#include "nm-ssh-editor-plugin.h"
+
+#ifdef NM_VPN_OLD
+#include "nm-ssh-editor.h"
+#else
+#include "nm-utils/nm-vpn-plugin-utils.h"
+#endif
+
+#define SSH_PLUGIN_NAME    _("SSH")
+#define SSH_PLUGIN_DESC    _("Compatible with the SSH server.")
+#define SSH_PLUGIN_SERVICE NM_DBUS_SERVICE_SSH
+
+#define PARSE_IMPORT_KEY(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN) \
+if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
+	nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
+	g_free(ITEMS); \
+	continue; \
+}
+
+#define PARSE_IMPORT_KEY_BOOL(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, VALUE) \
+if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
+	if (!strncmp(ITEMS[1], VALUE, strlen(ITEMS[1]))) { \
+		g_message("%s=%s", NM_SSH_KEY, ITEMS[1]); \
+		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, YES); \
+	} \
+	g_free (ITEMS); \
+	continue; \
+}
+
+#define PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, DEFAULT_VALUE) \
+if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
+	if (strncmp(ITEMS[1], DEFAULT_VALUE, strlen(ITEMS[1]))) \
+		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
+	g_free (ITEMS); \
+	continue; \
+}
+
+#define PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, DEFAULT_VALUE) \
+if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
+	char *tmp = g_strdup_printf("%d", DEFAULT_VALUE); \
+	if (strncmp(ITEMS[1], tmp, strlen(ITEMS[1]))) \
+		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
+	g_free (ITEMS); \
+	g_free (tmp); \
+	continue; \
+}
+
+enum {
+	PROP_0,
+	PROP_NAME,
+	PROP_DESC,
+	PROP_SERVICE
+};
+
+static void ssh_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class);
+
+G_DEFINE_TYPE_EXTENDED (SshEditorPlugin, ssh_editor_plugin, G_TYPE_OBJECT, 0,
+						G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR_PLUGIN,
+											   ssh_editor_plugin_interface_init))
+
+static NMConnection *
+import (NMVpnEditorPlugin *iface, const char *path, GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSettingVpn *s_vpn;
+	char *contents = NULL;
+	char **lines = NULL;
+	char *ext;
+	char **line;
+
+	ext = strrchr (path, '.');
+	if (!ext) {
+		g_set_error (error,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FAILED,
+		             "unknown SSH file extension, should be .sh");
+		goto out;
+	}
+
+	if (strncmp (ext, ".sh", strlen(".sh"))) {
+		g_set_error (error,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FAILED,
+		             "unknown SSH file extension, should be .sh");
+		goto out;
+	}
+
+	if (!g_file_get_contents (path, &contents, NULL, error))
+		return NULL;
+
+	if (!g_utf8_validate (contents, -1, NULL)) {
+		char *tmp;
+		GError *conv_error = NULL;
+
+		tmp = g_locale_to_utf8 (contents, -1, NULL, NULL, &conv_error);
+		if (conv_error) {
+			/* ignore the error, we tried at least. */
+			g_error_free (conv_error);
+			g_free (tmp);
+		} else {
+			g_assert (tmp);
+			g_free (contents);
+			contents = tmp;  /* update contents with the UTF-8 safe text */
+		}
+	}
+
+	lines = g_strsplit_set (contents, "\r\n", 0);
+	if (g_strv_length (lines) <= 1) {
+		g_set_error (error,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_FAILED,
+		             "not a valid SSH configuration file");
+		goto out;
+	}
+
+	connection = nm_simple_connection_new ();
+	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	s_vpn = NM_SETTING_VPN (nm_setting_vpn_new ());
+
+	g_object_set (s_vpn, NM_SETTING_VPN_SERVICE_TYPE, NM_DBUS_SERVICE_SSH, NULL);
+
+	for (line = lines; *line; line++) {
+		char *comment;
+		char **items = NULL;
+
+		if ((comment = strchr (*line, '#')))
+			*comment = '\0';
+		if ((comment = strchr (*line, ';')))
+			*comment = '\0';
+		if (!strlen (*line))
+			continue;
+
+		items = g_strsplit_set (*line, "=", 0);
+		if (!items) {
+			continue;
+		} else {
+			/* Uncomment if you'd like to debug parsing of items */
+			/* g_message("%s = %s", items[0], items[1]); */
+		}
+
+		/* the PARSE_IMPORT_KEY will save heaps of lines of code, it's
+		 * on the top of the file if you're looking for it */
+		PARSE_IMPORT_KEY (REMOTE_KEY, NM_SSH_KEY_REMOTE, items, s_vpn)
+		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR (AUTH_TYPE_KEY, NM_SSH_KEY_AUTH_TYPE, items, s_vpn, NM_SSH_AUTH_TYPE_SSH_AGENT)
+		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR (REMOTE_USERNAME_KEY, NM_SSH_KEY_REMOTE_USERNAME, items, s_vpn, NM_SSH_DEFAULT_REMOTE_USERNAME);
+		PARSE_IMPORT_KEY (KEY_FILE_KEY, NM_SSH_KEY_KEY_FILE, items, s_vpn)
+		PARSE_IMPORT_KEY (REMOTE_IP_KEY, NM_SSH_KEY_REMOTE_IP, items, s_vpn)
+		PARSE_IMPORT_KEY (LOCAL_IP_KEY, NM_SSH_KEY_LOCAL_IP, items, s_vpn)
+		PARSE_IMPORT_KEY (NETMASK_KEY, NM_SSH_KEY_NETMASK, items, s_vpn)
+		PARSE_IMPORT_KEY (IP_6_KEY, NM_SSH_KEY_IP_6, items, s_vpn)
+		PARSE_IMPORT_KEY (REMOTE_IP_6_KEY, NM_SSH_KEY_REMOTE_IP_6, items, s_vpn)
+		PARSE_IMPORT_KEY (LOCAL_IP_6_KEY, NM_SSH_KEY_LOCAL_IP_6, items, s_vpn)
+		PARSE_IMPORT_KEY (NETMASK_6_KEY, NM_SSH_KEY_NETMASK_6, items, s_vpn)
+		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (PORT_KEY, NM_SSH_KEY_PORT, items, s_vpn, NM_SSH_DEFAULT_PORT)
+		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (MTU_KEY, NM_SSH_KEY_TUNNEL_MTU, items, s_vpn, NM_SSH_DEFAULT_MTU)
+		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (REMOTE_DEV_KEY, NM_SSH_KEY_REMOTE_DEV, items, s_vpn, NM_SSH_DEFAULT_REMOTE_DEV)
+		PARSE_IMPORT_KEY_BOOL (DEV_TYPE_KEY, NM_SSH_KEY_TAP_DEV, items, s_vpn, "tap")
+	}
+
+	if (connection)
+		nm_connection_add_setting (connection, NM_SETTING (s_vpn));
+	else if (s_vpn)
+		g_object_unref (s_vpn);
+
+out:
+	if (lines)
+		g_strfreev (lines);
+	g_free (contents);
+	return connection;
+}
+
+static gboolean
+export (NMVpnEditorPlugin *iface,
+        const char *path,
+        NMConnection *connection,
+        GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingVpn *s_vpn;
+	FILE *f;
+	const char *value;
+	const char *auth_type = NULL;
+	const char *key_file = NULL;
+	const char *gateway = NULL;
+	const char *port = NULL;
+	const char *local_ip = NULL;
+	const char *remote_ip = NULL;
+	const char *netmask = NULL;
+	const char *local_ip_6 = NULL;
+	const char *remote_ip_6 = NULL;
+	const char *netmask_6 = NULL;
+	const char *remote_dev = NULL;
+	const char *mtu = NULL;
+	const char *remote_username = NULL;
+	char *device_type = NULL;
+	char *tunnel_type = NULL;
+	char *ifconfig_cmd_local_6 = NULL;
+	char *ifconfig_cmd_remote_6 = NULL;
+	char *preferred_authentication = NULL;
+	unsigned password_prompt_nr = 0;
+	gboolean ipv6 = FALSE;
+	gboolean success = FALSE;
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	s_vpn = (NMSettingVpn *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
+
+	f = fopen (path, "w");
+	if (!f) {
+		g_set_error (error, 0, 0, "could not open file for writing");
+		return FALSE;
+	}
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE);
+	if (value && strlen (value))
+		gateway = value;
+	else {
+		g_set_error (error, 0, 0, "connection was incomplete (missing gateway)");
+		goto done;
+	}
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP);
+	if (value && strlen (value))
+		remote_ip = value;
+	else {
+		g_set_error (error, 0, 0, "connection was incomplete (missing remote IP)");
+		goto done;
+	}
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP);
+	if (value && strlen (value))
+		local_ip = value;
+	else {
+		g_set_error (error, 0, 0, "connection was incomplete (missing local IP)");
+		goto done;
+	}
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK);
+	if (value && strlen (value))
+		netmask = value;
+	else {
+		g_set_error (error, 0, 0, "connection was incomplete (missing netmask)");
+		goto done;
+	}
+
+	/* Auth type */
+	auth_type = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_AUTH_TYPE);
+	if (auth_type) {
+		if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_PASSWORD, strlen(NM_SSH_AUTH_TYPE_PASSWORD))) {
+			password_prompt_nr = 1;
+			preferred_authentication = g_strdup("password");
+		} else if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_KEY, strlen(NM_SSH_AUTH_TYPE_KEY))) {
+			key_file = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_KEY_FILE);
+			preferred_authentication = g_strdup("publickey");
+		} else { // (!strncmp (auth_type, NM_SSH_AUTH_TYPE_SSH_AGENT, strlen(NM_SSH_AUTH_TYPE_SSH_AGENT))) {
+			// Nothing to be done for ssh-agent, the wise choice...
+			preferred_authentication = g_strdup("publickey");
+		}
+	}
+	/* Auth type */
+
+	/* Advanced values start */
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_PORT);
+	if (value && strlen (value))
+		port = value;
+	else
+		port = g_strdup_printf("%d", NM_SSH_DEFAULT_PORT);
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TUNNEL_MTU);
+	if (value && strlen (value))
+		mtu = value;
+	else
+		mtu = g_strdup_printf("%d", NM_SSH_DEFAULT_MTU);
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_DEV);
+	if (value && strlen (value))
+		remote_dev = value;
+	else
+		remote_dev = g_strdup_printf("%d", NM_SSH_DEFAULT_REMOTE_DEV);
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_USERNAME);
+	if (value && strlen (value))
+		remote_username = value;
+	else
+		remote_username = g_strdup(NM_SSH_DEFAULT_REMOTE_USERNAME);
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TAP_DEV);
+	if (value && IS_YES(value)) {
+		device_type = g_strdup("tap");
+		tunnel_type = g_strdup("ethernet");
+	} else {
+		device_type = g_strdup("tun");
+		tunnel_type = g_strdup("point-to-point");
+	}
+
+	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_IP_6);
+	if (value && IS_YES(value)) {
+		ipv6 = TRUE;
+
+		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP_6);
+		if (value && strlen (value))
+			remote_ip_6 = value;
+		else {
+			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 remote IP)");
+			goto done;
+		}
+
+		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP_6);
+		if (value && strlen (value))
+			local_ip_6 = value;
+		else {
+			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 local IP)");
+			goto done;
+		}
+
+		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK_6);
+		if (value && strlen (value))
+			netmask_6 = value;
+		else {
+			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 netmask)");
+			goto done;
+		}
+
+		ifconfig_cmd_local_6 = g_strdup_printf("%s $DEV_TYPE$LOCAL_DEV add $LOCAL_IP_6/$NETMASK_6", IFCONFIG);
+		ifconfig_cmd_remote_6 = g_strdup_printf("%s $DEV_TYPE$REMOTE_DEV add $REMOTE_IP_6/$NETMASK_6", IFCONFIG);
+	} else {
+		ipv6 = FALSE;
+		ifconfig_cmd_local_6 = g_strdup("");
+		ifconfig_cmd_remote_6 = g_strdup("");
+	}
+
+	/* Advanced values end */
+
+	/* Serialize everything to a file */
+	fprintf (f, "#!/bin/bash\n");
+	/* Make my life easier and just add the AUTH_TYPE= key, not used though */
+	fprintf (f, "%s=%s\n", AUTH_TYPE_KEY, auth_type);
+	if (key_file) {
+		fprintf (f, "%s=%s\n", KEY_FILE_KEY, key_file);
+	}
+	fprintf (f, "%s=%s\n", REMOTE_KEY, gateway);
+	fprintf (f, "%s=%s\n", REMOTE_USERNAME_KEY, remote_username);
+	fprintf (f, "%s=%s\n", REMOTE_IP_KEY, remote_ip);
+	fprintf (f, "%s=%s\n", LOCAL_IP_KEY, local_ip);
+	fprintf (f, "%s=%s\n", NETMASK_KEY, netmask);
+	if (ipv6) {
+		fprintf (f, "%s=%s\n", IP_6_KEY, YES);
+		fprintf (f, "%s=%s\n", REMOTE_IP_6_KEY, remote_ip_6);
+		fprintf (f, "%s=%s\n", LOCAL_IP_6_KEY, local_ip_6);
+		fprintf (f, "%s=%s\n", NETMASK_6_KEY, netmask_6);
+	}
+	fprintf (f, "%s=%s\n", PORT_KEY, port);
+	fprintf (f, "%s=%s\n", MTU_KEY, mtu);
+	fprintf (f, "%s=%s\n", REMOTE_DEV_KEY, remote_dev);
+
+	/* Assign tun/tap */
+	fprintf (f, "%s=%s\n", DEV_TYPE_KEY, device_type);
+	fprintf (f, "%s=%s\n", TUNNEL_TYPE_KEY, tunnel_type);
+
+	/* Add a little of bash script to probe for a free tun/tap device */
+	fprintf (f, "for i in `seq 0 255`; do ! %s $DEV_TYPE$i >& /dev/null && LOCAL_DEV=$i && break; done", IFCONFIG);
+
+	/* The generic lines that will perform the connection */
+	fprintf (f, "\n");
+	fprintf(f, "ssh -f %s -o PreferredAuthentications=%s -o NumberOfPasswordPrompts=%d -o Tunnel=$TUNNEL_TYPE -o ServerAliveInterval=10 -o TCPKeepAlive=yes -o TunnelDevice=$LOCAL_DEV:$REMOTE_DEV -o User=$REMOTE_USERNAME -o Port=$PORT -o HostName=$REMOTE $REMOTE \"%s $DEV_TYPE$REMOTE_DEV $REMOTE_IP netmask $NETMASK pointopoint $LOCAL_IP; %s\" && \\\n",
+		(key_file ? g_strconcat("-i ", key_file, NULL) : ""),
+		preferred_authentication,
+		password_prompt_nr,
+		IFCONFIG,
+		ifconfig_cmd_remote_6);
+	fprintf(f, "%s $DEV_TYPE$LOCAL_DEV $LOCAL_IP netmask $NETMASK pointopoint $REMOTE_IP; %s\n", IFCONFIG, ifconfig_cmd_local_6);
+
+	success = TRUE;
+
+	g_free(device_type);
+	g_free(tunnel_type);
+	g_free(ifconfig_cmd_local_6);
+	g_free(ifconfig_cmd_remote_6);
+	g_free(preferred_authentication);
+
+done:
+	fclose (f);
+	return success;
+}
+
+static char *
+get_suggested_filename (NMVpnEditorPlugin *iface, NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+	const char *id;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	id = nm_setting_connection_get_id (s_con);
+	g_return_val_if_fail (id != NULL, NULL);
+
+	return g_strdup_printf ("%s (ssh).sh", id);
+}
+
+static guint32
+get_capabilities (NMVpnEditorPlugin *iface)
+{
+	return (NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT | NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT | NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6);
+}
+
+#ifndef NM_VPN_OLD
+static NMVpnEditor *
+_call_editor_factory (gpointer factory,
+                      NMVpnEditorPlugin *editor_plugin,
+                      NMConnection *connection,
+                      gpointer user_data,
+                      GError **error)
+{
+	return ((NMVpnEditorFactory) factory) (editor_plugin,
+	                                       connection,
+	                                       error);
+}
+#endif
+
+static NMVpnEditor *
+get_editor (NMVpnEditorPlugin *iface, NMConnection *connection, GError **error)
+{
+	gpointer gtk3_only_symbol;
+	GModule *self_module;
+	const char *editor;
+
+	g_return_val_if_fail (SSH_IS_EDITOR_PLUGIN (iface), NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+
+	self_module = g_module_open (NULL, 0);
+	g_module_symbol (self_module, "gtk_container_add", &gtk3_only_symbol);
+	g_module_close (self_module);
+
+	if (gtk3_only_symbol) {
+		editor = "libnm-gtk3-vpn-plugin-ssh-editor.so";
+	} else {
+		editor = "libnm-gtk4-vpn-plugin-ssh-editor.so";
+	}
+
+#ifdef NM_VPN_OLD
+	return nm_ssh_editor_new (connection, error);
+#else
+	return nm_vpn_plugin_utils_load_editor (editor,
+						"nm_vpn_editor_factory_ssh",
+						_call_editor_factory,
+						iface,
+						connection,
+						NULL,
+						error);
+#endif
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	case PROP_NAME:
+		g_value_set_string (value, SSH_PLUGIN_NAME);
+		break;
+	case PROP_DESC:
+		g_value_set_string (value, SSH_PLUGIN_DESC);
+		break;
+	case PROP_SERVICE:
+		g_value_set_string (value, SSH_PLUGIN_SERVICE);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+ssh_editor_plugin_class_init (SshEditorPluginClass *req_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
+
+	object_class->get_property = get_property;
+
+	g_object_class_override_property (object_class,
+									  PROP_NAME,
+									  NM_VPN_EDITOR_PLUGIN_NAME);
+
+	g_object_class_override_property (object_class,
+									  PROP_DESC,
+									  NM_VPN_EDITOR_PLUGIN_DESCRIPTION);
+
+	g_object_class_override_property (object_class,
+									  PROP_SERVICE,
+									  NM_VPN_EDITOR_PLUGIN_SERVICE);
+}
+
+static void
+ssh_editor_plugin_init (SshEditorPlugin *plugin)
+{
+}
+
+static void
+ssh_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class)
+{
+	/* interface implementation */
+	iface_class->get_editor = get_editor;
+	iface_class->get_capabilities = get_capabilities;
+	iface_class->import_from_file = import;
+	iface_class->export_to_file = export;
+	iface_class->get_suggested_filename = get_suggested_filename;
+}
+
+G_MODULE_EXPORT NMVpnEditorPlugin *
+nm_vpn_editor_plugin_factory (GError **error)
+{
+	if (error)
+		g_return_val_if_fail (*error == NULL, NULL);
+
+	return g_object_new (SSH_TYPE_EDITOR_PLUGIN, NULL);
+}
diff --git a/properties/nm-ssh.h b/properties/nm-ssh-editor-plugin.h
similarity index 68%
rename from properties/nm-ssh.h
rename to properties/nm-ssh-editor-plugin.h
index 9e460ce..d187a1f 100644
--- a/properties/nm-ssh.h
+++ b/properties/nm-ssh-editor-plugin.h
@@ -1,8 +1,8 @@
 /* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /***************************************************************************
- * nm-ssh.h : GNOME UI dialogs for configuring ssh VPN connections
  *
  * Copyright (C) 2013 Dan Fruehauf, <malkodan@gmail.com>
+ * Copyright (C) 2022 Red Hat, Inc.
  * Based on work by Dan Williams, <dcbw@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,8 +21,8 @@
  *
  **************************************************************************/
 
-#ifndef _NM_SSH_H_
-#define _NM_SSH_H_
+#ifndef _NM_SSH_EDITOR_PLUGIN_H_
+#define _NM_SSH_EDITOR_PLUGIN_H_
 
 #include <glib-object.h>
 
@@ -46,36 +46,13 @@ struct _SshEditorPluginClass {
 
 GType ssh_editor_plugin_get_type (void);
 
+NMVpnEditor *nm_vpn_editor_factory_ssh (NMVpnEditorPlugin *editor_plugin,
+                                        NMConnection *connection,
+                                        GError **error);
 
-#define SSH_TYPE_EDITOR            (ssh_editor_get_type ())
-#define SSH_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), SSH_TYPE_EDITOR, SshEditor))
-#define SSH_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), SSH_TYPE_EDITOR, SshEditorClass))
-#define SSH_IS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SSH_TYPE_EDITOR))
-#define SSH_IS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), SSH_TYPE_EDITOR))
-#define SSH_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), SSH_TYPE_EDITOR, SshEditorClass))
-
-typedef struct _SshEditor SshEditor;
-typedef struct _SshEditorClass SshEditorClass;
-
-struct _SshEditor {
-	GObject parent;
-};
-
-struct _SshEditorClass {
-	GObjectClass parent;
-};
-
-GType ssh_editor_get_type (void);
-
-typedef void (*ChangedCallback) (GtkWidget *widget, gpointer user_data);
-
-void init_auth_widget (GtkBuilder *builder,
-                       GtkSizeGroup *group,
-                       NMSettingVpn *s_vpn,
-                       const char *contype,
-                       const char *prefix,
-                       ChangedCallback changed_cb,
-                       gpointer user_data);
+typedef NMVpnEditor *(*NMVpnEditorFactory) (NMVpnEditorPlugin *editor_plugin,
+                                            NMConnection *connection,
+                                            GError **error);
 
 /* Export/Import key dictionary */
 #define	REMOTE_KEY "REMOTE"
@@ -98,5 +75,5 @@ void init_auth_widget (GtkBuilder *builder,
 #define	NO_DEFAULT_ROUTE_KEY "NO_DEFAULT_ROUTE"
 #define	TUNNEL_TYPE_KEY "TUNNEL_TYPE"
 
-#endif	/* _NM_SSH_H_ */
+#endif	/* _NM_SSH_EDITOR_PLUGIN_H_ */
 
diff --git a/properties/nm-ssh.c b/properties/nm-ssh-editor.c
similarity index 52%
rename from properties/nm-ssh.c
rename to properties/nm-ssh-editor.c
index 8f24232..73e8a65 100644
--- a/properties/nm-ssh.c
+++ b/properties/nm-ssh-editor.c
@@ -1,10 +1,8 @@
 /* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /***************************************************************************
- * CVSID: $Id: nm-ssh.c 4232 2008-10-29 09:13:40Z tambeti $
- *
- * nm-ssh.c : GNOME UI dialogs for configuring ssh VPN connections
  *
  * Copyright (C) 2013 Dan Fruehauf, <malkodan@gmail.com>
+ * Copyright (C) 2022 Red Hat, Inc.
  * Based on work by Dan Williams, <dcbw@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -23,106 +21,13 @@
  *
  **************************************************************************/
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <glib/gi18n-lib.h>
-#include <string.h>
-#include <gtk/gtk.h>
-
-#define NM_VPN_API_SUBJECT_TO_CHANGE
-
-#ifdef NM_SSH_OLD
-#define NM_VPN_LIBNM_COMPAT
-#include <nm-vpn-plugin-ui-interface.h>
-#include <nm-setting-vpn.h>
-#include <nm-setting-connection.h>
-#include <nm-setting-ip4-config.h>
-
-#define SSH_EDITOR_PLUGIN_ERROR                     NM_SETTING_VPN_ERROR
-#define SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_SETTING_VPN_ERROR_INVALID_PROPERTY
-#define SSH_EDITOR_PLUGIN_ERROR_FAILED              NM_SETTING_VPN_ERROR_UNKNOWN
-
-#define nm_simple_connection_new nm_connection_new
-
-#else /* !NM_SSH_OLD */
-
-#include <NetworkManager.h>
-
-#define SSH_EDITOR_PLUGIN_ERROR                     NM_CONNECTION_ERROR
-#define SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_CONNECTION_ERROR_INVALID_PROPERTY
-#define SSH_EDITOR_PLUGIN_ERROR_FAILED              NM_CONNECTION_ERROR_FAILED
-#endif
-
-#include "src/nm-ssh-service-defines.h"
-#include "nm-ssh.h"
+#include "nm-default.h"
+#include "nm-ssh-editor.h"
 #include "advanced-dialog.h"
 
-#define SSH_PLUGIN_NAME    _("SSH")
-#define SSH_PLUGIN_DESC    _("Compatible with the SSH server.")
-#define SSH_PLUGIN_SERVICE NM_DBUS_SERVICE_SSH 
-
 #define PW_TYPE_SAVE   0
 #define PW_TYPE_ASK    1
 
-#define PARSE_IMPORT_KEY(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN) \
-if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
-	nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
-	g_free(ITEMS); \
-	continue; \
-}
-
-#define PARSE_IMPORT_KEY_BOOL(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, VALUE) \
-if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
-	if (!strncmp(ITEMS[1], VALUE, strlen(ITEMS[1]))) { \
-		g_message("%s=%s", NM_SSH_KEY, ITEMS[1]); \
-		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, YES); \
-	} \
-	g_free (ITEMS); \
-	continue; \
-}
-
-#define PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, DEFAULT_VALUE) \
-if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
-	if (strncmp(ITEMS[1], DEFAULT_VALUE, strlen(ITEMS[1]))) \
-		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
-	g_free (ITEMS); \
-	continue; \
-}
-
-#define PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT(IMPORT_KEY, NM_SSH_KEY, ITEMS, VPN_CONN, DEFAULT_VALUE) \
-if (!strncmp (ITEMS[0], IMPORT_KEY, strlen (ITEMS[0]))) { \
-	char *tmp = g_strdup_printf("%d", DEFAULT_VALUE); \
-	if (strncmp(ITEMS[1], tmp, strlen(ITEMS[1]))) \
-		nm_setting_vpn_add_data_item (VPN_CONN, NM_SSH_KEY, ITEMS[1]); \
-	g_free (ITEMS); \
-	g_free (tmp); \
-	continue; \
-}
-
-
-/************** plugin class **************/
-
-enum {
-	PROP_0,
-	PROP_NAME,
-	PROP_DESC,
-	PROP_SERVICE
-};
-
-static void ssh_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class);
-
-G_DEFINE_TYPE_EXTENDED (SshEditorPlugin, ssh_editor_plugin, G_TYPE_OBJECT, 0,
-						G_IMPLEMENT_INTERFACE (NM_TYPE_VPN_EDITOR_PLUGIN,
-											   ssh_editor_plugin_interface_init))
-
-/************** UI widget class **************/
-
 static void ssh_editor_interface_init (NMVpnEditorInterface *iface_class);
 
 G_DEFINE_TYPE_EXTENDED (SshEditor, ssh_editor, G_TYPE_OBJECT, 0,
@@ -139,6 +44,7 @@ typedef struct {
 	gboolean window_added;
 	GHashTable *advanced;
 	gboolean new_connection;
+	GFile *keyfile;
 } SshEditorPrivate;
 
 
@@ -154,41 +60,41 @@ check_validity (SshEditor *self, GError **error)
 	const char *str;
 
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (!str || !strlen (str)) {
 		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_SSH_KEY_REMOTE);
 		return FALSE;
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "remote_ip_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (!str || !strlen (str)) {
 		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_SSH_KEY_REMOTE_IP);
 		return FALSE;
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "local_ip_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (!str || !strlen (str)) {
 		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_SSH_KEY_LOCAL_IP);
 		return FALSE;
 	}
 
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "netmask_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (!str || !strlen (str)) {
 		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
+		             NMV_EDITOR_PLUGIN_ERROR,
+		             NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY,
 		             NM_SSH_KEY_NETMASK);
 		return FALSE;
 	}
@@ -197,9 +103,9 @@ check_validity (SshEditor *self, GError **error)
 }
 
 static void
-show_password_toggled (GtkToggleButton *togglebutton, GtkEntry *password_entry)
+show_password_toggled (GtkCheckButton *checkbutton, GtkEntry *password_entry)
 {
-	gtk_entry_set_visibility (password_entry, gtk_toggle_button_get_active (togglebutton));
+	gtk_entry_set_visibility (password_entry, gtk_check_button_get_active (checkbutton));
 }
 
 static void
@@ -215,7 +121,7 @@ auth_combo_changed_cb (GtkWidget *combo, gpointer user_data)
 	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
 	GtkWidget *auth_notebook;
 	GtkWidget *show_password;
-	GtkWidget *file_chooser;
+	GtkWidget *keyfile_button;
 	GtkTreeModel *model;
 	GtkTreeIter iter;
 	gint new_page = 0;
@@ -224,8 +130,8 @@ auth_combo_changed_cb (GtkWidget *combo, gpointer user_data)
 	g_assert (auth_notebook);
 	show_password = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_password_show_password_checkbutton"));
 	g_assert (show_password);
-	file_chooser = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_keyfile_filechooserbutton"));
-	g_assert (file_chooser);
+	keyfile_button = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_keyfile_button"));
+	g_assert (keyfile_button);
 
 	model = gtk_combo_box_get_model (GTK_COMBO_BOX (combo));
 	g_assert (model);
@@ -237,7 +143,7 @@ auth_combo_changed_cb (GtkWidget *combo, gpointer user_data)
 	gtk_widget_set_sensitive (show_password, new_page == 1);
 
 	/* Key file entry relevant only to key page (2) */
-	gtk_widget_set_sensitive (file_chooser, new_page == 2);
+	gtk_widget_set_sensitive (keyfile_button, new_page == 2);
 
 	gtk_notebook_set_current_page (GTK_NOTEBOOK (auth_notebook), new_page);
 
@@ -248,8 +154,8 @@ static void
 advanced_dialog_close_cb (GtkWidget *dialog, gpointer user_data)
 {
 	gtk_widget_hide (dialog);
-	/* gtk_widget_destroy() will remove the window from the window group */
-	gtk_widget_destroy (dialog);
+	/* gtk_window_destroy() will remove the window from the window group */
+	gtk_window_destroy (GTK_WINDOW(dialog));
 }
 
 static void
@@ -281,10 +187,11 @@ advanced_button_clicked_cb (GtkWidget *button, gpointer user_data)
 {
 	SshEditor *self = SSH_EDITOR (user_data);
 	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
-	GtkWidget *dialog, *toplevel;
+	GtkWidget *dialog;
+	GtkRoot *root;
 
-	toplevel = gtk_widget_get_toplevel (priv->widget);
-	g_return_if_fail (gtk_widget_is_toplevel (toplevel));
+	root = gtk_widget_get_root (priv->widget);
+	g_return_if_fail (GTK_IS_WINDOW(root));
 
 	dialog = advanced_dialog_new (priv->advanced);
 	if (!dialog) {
@@ -294,15 +201,15 @@ advanced_button_clicked_cb (GtkWidget *button, gpointer user_data)
 
 	gtk_window_group_add_window (priv->window_group, GTK_WINDOW (dialog));
 	if (!priv->window_added) {
-		gtk_window_group_add_window (priv->window_group, GTK_WINDOW (toplevel));
+		gtk_window_group_add_window (priv->window_group, GTK_WINDOW (root));
 		priv->window_added = TRUE;
 	}
 
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (toplevel));
+	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (root));
 	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (advanced_dialog_response_cb), self);
 	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (advanced_dialog_close_cb), self);
 
-	gtk_widget_show_all (dialog);
+	gtk_widget_show (dialog);
 }
 
 static void
@@ -312,28 +219,76 @@ ipv6_toggled_cb (GtkWidget *check, gpointer user_data)
 	GtkWidget *widget;
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "remote_ip_6_entry"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "local_ip_6_entry"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "netmask_6_entry"));
-	gtk_widget_set_sensitive (widget, gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (check)));
+	gtk_widget_set_sensitive (widget, gtk_check_button_get_active (GTK_CHECK_BUTTON (check)));
 }
 
-void
-init_auth_widget (GtkBuilder *builder,
+static void
+chooser_show (GtkWidget *parent, GtkWidget *widget)
+{
+	GtkRoot *root;
+
+	root = gtk_widget_get_root (parent);
+	g_return_if_fail (GTK_IS_WINDOW(root));
+
+	gtk_window_set_transient_for (GTK_WINDOW (widget), GTK_WINDOW (root));
+	gtk_widget_show (widget);
+}
+
+static void
+chooser_button_update_file (SshEditor *self)
+{
+	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
+	char *basename = NULL;
+	GtkLabel *label;
+
+	label = GTK_LABEL (gtk_builder_get_object (priv->builder,
+	                                           "auth_keyfile_button_label"));
+
+	if (priv->keyfile)
+		basename = g_file_get_basename (priv->keyfile);
+	if (basename) {
+		gtk_label_set_label (label, basename);
+		g_free (basename);
+	} else {
+		gtk_label_set_label (label, _("(None)"));
+	}
+}
+
+static void
+chooser_response (GtkDialog *chooser, gint response_id, gpointer user_data)
+{
+	SshEditor *self = SSH_EDITOR (user_data);
+	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
+
+	if (response_id == GTK_RESPONSE_ACCEPT) {
+		if (priv->keyfile)
+			g_object_unref (priv->keyfile);
+		priv->keyfile = gtk_file_chooser_get_file (GTK_FILE_CHOOSER (chooser));
+		chooser_button_update_file (self);
+		stuff_changed_cb (GTK_WIDGET (chooser), self);
+	}
+
+	gtk_widget_hide (GTK_WIDGET (chooser));
+}
+
+static void
+init_auth_widget (SshEditor *self,
+                         GtkBuilder *builder,
                          GtkSizeGroup *group,
                          NMSettingVpn *s_vpn,
                          const char *contype,
-                         const char *prefix,
-                         ChangedCallback changed_cb,
-                         gpointer user_data)
+                         const char *prefix)
 {
+	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
 	GtkWidget *widget, *widget2;
 	g_return_if_fail (builder != NULL);
 	g_return_if_fail (group != NULL);
-	g_return_if_fail (changed_cb != NULL);
 	g_return_if_fail (prefix != NULL);
 
 	/* Three major connection types here: ssh-agent, key file, password */
@@ -346,14 +301,14 @@ init_auth_widget (GtkBuilder *builder,
 		widget2 = GTK_WIDGET (gtk_builder_get_object (builder, "auth_password_entry"));
 		g_assert (widget2);
 		g_signal_connect (widget, "toggled", G_CALLBACK (show_password_toggled), widget2);
-		show_password_toggled (GTK_TOGGLE_BUTTON (widget), GTK_ENTRY (widget2));
+		show_password_toggled (GTK_CHECK_BUTTON (widget), GTK_ENTRY (widget2));
 
 		/* Load password */
-		g_signal_connect (G_OBJECT (widget2), "changed", G_CALLBACK (changed_cb), user_data);
+		g_signal_connect (G_OBJECT (widget2), "changed", G_CALLBACK (stuff_changed_cb), self);
 		if (s_vpn) {
 			password = nm_setting_vpn_get_secret (s_vpn, NM_SSH_KEY_PASSWORD);
 			if (password)
-				gtk_entry_set_text (GTK_ENTRY (widget2), password);
+				gtk_editable_set_text (GTK_EDITABLE (widget2), password);
 
 			nm_setting_get_secret_flags (NM_SETTING (s_vpn), NM_SSH_KEY_PASSWORD, &pw_flags, NULL);
 			/* FIXME */
@@ -363,16 +318,26 @@ init_auth_widget (GtkBuilder *builder,
 	else if (!strncmp (contype, NM_SSH_AUTH_TYPE_KEY, strlen(NM_SSH_AUTH_TYPE_KEY))) {
 		/* Get key filename and set it */
 		const gchar *filename;
-		widget = GTK_WIDGET (gtk_builder_get_object (builder, "auth_keyfile_filechooserbutton"));
-		/* FIXME add filter */
-		//gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (widget), filter);
-		gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER (widget), TRUE);
+
+		widget = GTK_WIDGET (gtk_builder_get_object (builder, "auth_keyfile_chooser"));
+		gtk_window_set_hide_on_close (GTK_WINDOW(widget), TRUE);
+		g_signal_connect (gtk_builder_get_object (builder, "auth_keyfile_button"),
+		                  "clicked", G_CALLBACK (chooser_show), widget);
+
+		g_signal_connect (G_OBJECT (widget), "response", G_CALLBACK (chooser_response), self);
 		if (s_vpn) {
 			filename = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_KEY_FILE);
-			if (filename && strlen (filename))
-				gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (widget), filename);
+			if (filename && strlen (filename)) {
+		                priv->keyfile = g_file_new_for_path (filename);
+		                gtk_file_chooser_set_file (GTK_FILE_CHOOSER (widget),
+				                           priv->keyfile, NULL);
+		        }
 		}
-		g_signal_connect (G_OBJECT (widget), "selection-changed", G_CALLBACK (changed_cb), user_data);
+
+		chooser_button_update_file (self);
+
+		/* FIXME add filter */
+		//gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (widget), filter);
 	} else if (!strncmp (contype, NM_SSH_AUTH_TYPE_SSH_AGENT, strlen(NM_SSH_AUTH_TYPE_SSH_AGENT))) {
 		/* ssh-agent is the default */
 		/* Not much to do here! No options for ssh-agent :) */
@@ -396,7 +361,7 @@ pw_type_combo_changed_cb (GtkWidget *combo, gpointer user_data)
 	 */
 	switch (gtk_combo_box_get_active (GTK_COMBO_BOX (combo))) {
 	case PW_TYPE_ASK:
-		gtk_entry_set_text (GTK_ENTRY (entry), "");
+		gtk_editable_set_text (GTK_EDITABLE (entry), "");
 		gtk_widget_set_sensitive (entry, FALSE);
 		break;
 	default:
@@ -429,7 +394,7 @@ init_one_pw_combo (
 	 */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, entry_name));
 	g_assert (widget);
-	value = gtk_entry_get_text (GTK_ENTRY (widget));
+	value = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (value && strlen (value))
 		default_idx = 0;
 
@@ -483,7 +448,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -494,7 +459,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -505,7 +470,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -516,7 +481,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -527,7 +492,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP_6);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -538,7 +503,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP_6);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -549,7 +514,7 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	if (s_vpn) {
 		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK_6);
 		if (value)
-			gtk_entry_set_text (GTK_ENTRY (widget), value);
+			gtk_editable_set_text (GTK_EDITABLE (widget), value);
 	}
 	g_signal_connect (G_OBJECT (widget), "changed", G_CALLBACK (stuff_changed_cb), self);
 
@@ -558,9 +523,9 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	g_assert (widget);
 	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_IP_6);
 	if (value && IS_YES(value)) {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), TRUE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), TRUE);
 	} else {
-		gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), FALSE);
+		gtk_check_button_set_active (GTK_CHECK_BUTTON (widget), FALSE);
 	}
 	/* Call the callback to show/hide IPv6 options */
 	ipv6_toggled_cb (widget, priv->builder);
@@ -570,9 +535,6 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "ipv6_label"));
 	g_assert (widget);
 	gtk_widget_show (widget);
-	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "ipv6_alignment"));
-	g_assert (widget);
-	gtk_widget_show (widget);
 
 	/* Authentication combo box */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_auth_type_combobox"));
@@ -593,9 +555,8 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 	}
 
 	/* SSH Agent auth widget */
-	init_auth_widget (priv->builder, priv->group, s_vpn,
-		NM_SSH_KEY_AUTH_TYPE, "ssh-agent",
-		stuff_changed_cb, self);
+	init_auth_widget (self, priv->builder, priv->group, s_vpn,
+		NM_SSH_KEY_AUTH_TYPE, "ssh-agent");
 	gtk_list_store_append (store, &iter);
 	gtk_list_store_set (store, &iter,
 		COL_AUTH_NAME, _("SSH Agent"),
@@ -606,9 +567,8 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 		active = 0;
 
 	/* Password auth widget */
-	init_auth_widget (priv->builder, priv->group, s_vpn,
-		NM_SSH_AUTH_TYPE_PASSWORD, "pw",
-		stuff_changed_cb, self);
+	init_auth_widget (self, priv->builder, priv->group, s_vpn,
+		NM_SSH_AUTH_TYPE_PASSWORD, "pw");
 	gtk_list_store_append (store, &iter);
 	gtk_list_store_set (store, &iter,
 		COL_AUTH_NAME, _("Password"),
@@ -619,9 +579,8 @@ init_editor_plugin (SshEditor *self, NMConnection *connection, GError **error)
 		active = 1;
 
 	/* Key auth widget */
-	init_auth_widget (priv->builder, priv->group, s_vpn,
-		NM_SSH_AUTH_TYPE_KEY, "key",
-		stuff_changed_cb, self);
+	init_auth_widget (self, priv->builder, priv->group, s_vpn,
+		NM_SSH_AUTH_TYPE_KEY, "key");
 	gtk_list_store_append (store, &iter);
 	gtk_list_store_set (store, &iter,
 		COL_AUTH_NAME, _("Key Authentication"),
@@ -673,10 +632,11 @@ hash_copy_advanced (gpointer key, gpointer data, gpointer user_data)
 }
 
 static gboolean auth_widget_update_connection (
-	GtkBuilder *builder,
+	SshEditor *self,
 	NMSettingVpn *s_vpn)
 {
 	/* This function populates s_vpn with the auth properties */
+	SshEditorPrivate *priv = SSH_EDITOR_GET_PRIVATE (self);
 	GtkWidget *widget;
 	GtkWidget *combo_password;
 	GtkComboBox *combo;
@@ -685,7 +645,8 @@ static gboolean auth_widget_update_connection (
 	char *auth_type = NULL;
 	gboolean success = TRUE;
 
-	combo = GTK_COMBO_BOX (GTK_WIDGET (gtk_builder_get_object (builder, "auth_auth_type_combobox")));
+	combo = GTK_COMBO_BOX (GTK_WIDGET (gtk_builder_get_object (priv->builder,
+	                                                           "auth_auth_type_combobox")));
 	model = gtk_combo_box_get_model (combo);
 
 	success = gtk_combo_box_get_active_iter (combo, &iter);
@@ -701,14 +662,15 @@ static gboolean auth_widget_update_connection (
 		NMSettingSecretFlags pw_flags = NM_SETTING_SECRET_FLAG_NONE;
 
 		/* Grab original password flags */
-		widget = GTK_WIDGET (gtk_builder_get_object (builder, "auth_password_entry"));
+		widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_password_entry"));
 		pw_flags = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (widget), "flags"));
-		combo_password = GTK_WIDGET (gtk_builder_get_object (builder, "auth_password_save_password_combobox"));
+		combo_password = GTK_WIDGET (gtk_builder_get_object (priv->builder,
+		                                                     "auth_password_save_password_combobox"));
 
 		/* And set new ones based on the type combo */
 		switch (gtk_combo_box_get_active (GTK_COMBO_BOX (combo_password))) {
 		case PW_TYPE_SAVE:
-			password = gtk_entry_get_text (GTK_ENTRY (widget));
+			password = gtk_editable_get_text (GTK_EDITABLE (widget));
 			if (password && strlen (password))
 				nm_setting_vpn_add_secret (s_vpn, NM_SSH_KEY_PASSWORD, password);
 			break;
@@ -724,11 +686,13 @@ static gboolean auth_widget_update_connection (
 	else if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_KEY, strlen(NM_SSH_AUTH_TYPE_KEY))) {
 		/* Key auth */
 		gchar *filename;
-		widget = GTK_WIDGET (gtk_builder_get_object (builder, "auth_keyfile_filechooserbutton"));
-		filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (widget));
-		if (filename && strlen (filename)) {
+		widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "auth_keyfile_chooser"));
+		if (priv->keyfile)
+			filename = g_file_get_path (priv->keyfile);
+		else
+			filename = NULL;
+		if (filename && strlen (filename))
 			nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_KEY_FILE, filename);
-		}
 		g_free (filename);
 	}
 	else if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_SSH_AGENT, strlen(NM_SSH_AUTH_TYPE_SSH_AGENT))) {
@@ -764,54 +728,54 @@ update_connection (NMVpnEditor *iface,
 
 	/* Gateway */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "gateway_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (str && strlen (str))
 		nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_REMOTE, str);
 
 	/* Remote IP */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "remote_ip_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (str && strlen (str))
 		nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP, str);
 
 	/* Local IP */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "local_ip_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (str && strlen (str))
 		nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP, str);
 
 	/* Netmask */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "netmask_entry"));
-	str = gtk_entry_get_text (GTK_ENTRY (widget));
+	str = gtk_editable_get_text (GTK_EDITABLE (widget));
 	if (str && strlen (str))
 		nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_NETMASK, str);
 
 	/* IPv6 enabled */
 	widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "ipv6_checkbutton"));
-	if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget))) {
+	if (gtk_check_button_get_active (GTK_CHECK_BUTTON (widget))) {
 		nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_IP_6, YES);
 
 		/* Remote IP IPv6 */
 		widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "remote_ip_6_entry"));
-		str = gtk_entry_get_text (GTK_ENTRY (widget));
+		str = gtk_editable_get_text (GTK_EDITABLE (widget));
 		if (str && strlen (str))
 			nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP_6, str);
 
 		/* Local IP IPv6 */
 		widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "local_ip_6_entry"));
-		str = gtk_entry_get_text (GTK_ENTRY (widget));
+		str = gtk_editable_get_text (GTK_EDITABLE (widget));
 		if (str && strlen (str))
 			nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP_6, str);
 
 		/* Prefix IPv6 */
 		widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "netmask_6_entry"));
-		str = gtk_entry_get_text (GTK_ENTRY (widget));
+		str = gtk_editable_get_text (GTK_EDITABLE (widget));
 		if (str && strlen (str))
 			nm_setting_vpn_add_data_item (s_vpn, NM_SSH_KEY_NETMASK_6, str);
 	}
 
 	/* Authentication type */
-	valid &= auth_widget_update_connection (priv->builder, s_vpn);
+	valid &= auth_widget_update_connection (self, s_vpn);
 
 	if (priv->advanced)
 		g_hash_table_foreach (priv->advanced, hash_copy_advanced, s_vpn);
@@ -831,12 +795,11 @@ is_new_func (const char *key, const char *value, gpointer user_data)
 	*is_new = FALSE;
 }
 
-static NMVpnEditor *
-nm_vpn_editor_interface_new (NMConnection *connection, GError **error)
+NMVpnEditor *
+nm_ssh_editor_new (NMConnection *connection, GError **error)
 {
 	NMVpnEditor *object;
 	SshEditorPrivate *priv;
-	char *ui_file;
 	gboolean new = TRUE;
 	NMSettingVpn *s_vpn;
 
@@ -845,33 +808,26 @@ nm_vpn_editor_interface_new (NMConnection *connection, GError **error)
 
 	object = g_object_new (SSH_TYPE_EDITOR, NULL);
 	if (!object) {
-		g_set_error (error, SSH_EDITOR_PLUGIN_ERROR, 0, "could not create ssh object");
+		g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, 0, "could not create ssh object");
 		return NULL;
 	}
 
 	priv = SSH_EDITOR_GET_PRIVATE (object);
 
-	ui_file = g_strdup_printf ("%s/%s", UIDIR, "nm-ssh-dialog.ui");
 	priv->builder = gtk_builder_new ();
 
 	gtk_builder_set_translation_domain (priv->builder, GETTEXT_PACKAGE);
 
-	if (!gtk_builder_add_from_file (priv->builder, ui_file, error)) {
+	if (!gtk_builder_add_from_resource (priv->builder, "/org/freedesktop/network-manager-ssh/nm-ssh-dialog.ui", error)) {
 		g_warning ("Couldn't load builder file: %s",
 		           error && *error ? (*error)->message : "(unknown)");
-		g_clear_error (error);
-		g_set_error (error, SSH_EDITOR_PLUGIN_ERROR, 0,
-		             "could not load required resources from %s", ui_file);
-		g_free (ui_file);
 		g_object_unref (object);
 		return NULL;
 	}
 
-	g_free (ui_file);
-
 	priv->widget = GTK_WIDGET (gtk_builder_get_object (priv->builder, "ssh_main_vbox"));
 	if (!priv->widget) {
-		g_set_error (error, SSH_EDITOR_PLUGIN_ERROR, 0, "could not load UI widget");
+		g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, 0, "could not load UI widget");
 		g_object_unref (object);
 		return NULL;
 	}
@@ -919,6 +875,9 @@ dispose (GObject *object)
 	if (priv->advanced)
 		g_hash_table_destroy (priv->advanced);
 
+	if (priv->keyfile)
+		g_object_unref (priv->keyfile);
+
 	G_OBJECT_CLASS (ssh_editor_parent_class)->dispose (object);
 }
 
@@ -945,426 +904,19 @@ ssh_editor_interface_init (NMVpnEditorInterface *iface_class)
 	iface_class->update_connection = update_connection;
 }
 
-static NMConnection *
-import (NMVpnEditorPlugin *iface, const char *path, GError **error)
-{
-	NMConnection *connection = NULL;
-	NMSettingConnection *s_con;
-	NMSettingVpn *s_vpn;
-	char *contents = NULL;
-	char **lines = NULL;
-	char *ext;
-	char **line;
-
-	ext = strrchr (path, '.');
-	if (!ext) {
-		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_FAILED,
-		             "unknown SSH file extension, should be .sh");
-		goto out;
-	}
-
-	if (strncmp (ext, ".sh", strlen(".sh"))) {
-		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_FAILED,
-		             "unknown SSH file extension, should be .sh");
-		goto out;
-	}
-
-	if (!g_file_get_contents (path, &contents, NULL, error))
-		return NULL;
-
-	if (!g_utf8_validate (contents, -1, NULL)) {
-		char *tmp;
-		GError *conv_error = NULL;
-
-		tmp = g_locale_to_utf8 (contents, -1, NULL, NULL, &conv_error);
-		if (conv_error) {
-			/* ignore the error, we tried at least. */
-			g_error_free (conv_error);
-			g_free (tmp);
-		} else {
-			g_assert (tmp);
-			g_free (contents);
-			contents = tmp;  /* update contents with the UTF-8 safe text */
-		}
-	}
-
-	lines = g_strsplit_set (contents, "\r\n", 0);
-	if (g_strv_length (lines) <= 1) {
-		g_set_error (error,
-		             SSH_EDITOR_PLUGIN_ERROR,
-		             SSH_EDITOR_PLUGIN_ERROR_FAILED,
-		             "not a valid SSH configuration file");
-		goto out;
-	}
-
-	connection = nm_simple_connection_new ();
-	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
-	nm_connection_add_setting (connection, NM_SETTING (s_con));
-
-	s_vpn = NM_SETTING_VPN (nm_setting_vpn_new ());
-
-	g_object_set (s_vpn, NM_SETTING_VPN_SERVICE_TYPE, NM_DBUS_SERVICE_SSH, NULL);
-
-	for (line = lines; *line; line++) {
-		char *comment;
-		char **items = NULL;
-
-		if ((comment = strchr (*line, '#')))
-			*comment = '\0';
-		if ((comment = strchr (*line, ';')))
-			*comment = '\0';
-		if (!strlen (*line))
-			continue;
-
-		items = g_strsplit_set (*line, "=", 0);
-		if (!items) {
-			continue;
-		} else {
-			/* Uncomment if you'd like to debug parsing of items */
-			/* g_message("%s = %s", items[0], items[1]); */
-		}
-
-		/* the PARSE_IMPORT_KEY will save heaps of lines of code, it's
-		 * on the top of the file if you're looking for it */
-		PARSE_IMPORT_KEY (REMOTE_KEY, NM_SSH_KEY_REMOTE, items, s_vpn)
-		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR (AUTH_TYPE_KEY, NM_SSH_KEY_AUTH_TYPE, items, s_vpn, NM_SSH_AUTH_TYPE_SSH_AGENT)
-		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_STR (REMOTE_USERNAME_KEY, NM_SSH_KEY_REMOTE_USERNAME, items, s_vpn, NM_SSH_DEFAULT_REMOTE_USERNAME);
-		PARSE_IMPORT_KEY (KEY_FILE_KEY, NM_SSH_KEY_KEY_FILE, items, s_vpn)
-		PARSE_IMPORT_KEY (REMOTE_IP_KEY, NM_SSH_KEY_REMOTE_IP, items, s_vpn)
-		PARSE_IMPORT_KEY (LOCAL_IP_KEY, NM_SSH_KEY_LOCAL_IP, items, s_vpn)
-		PARSE_IMPORT_KEY (NETMASK_KEY, NM_SSH_KEY_NETMASK, items, s_vpn)
-		PARSE_IMPORT_KEY (IP_6_KEY, NM_SSH_KEY_IP_6, items, s_vpn)
-		PARSE_IMPORT_KEY (REMOTE_IP_6_KEY, NM_SSH_KEY_REMOTE_IP_6, items, s_vpn)
-		PARSE_IMPORT_KEY (LOCAL_IP_6_KEY, NM_SSH_KEY_LOCAL_IP_6, items, s_vpn)
-		PARSE_IMPORT_KEY (NETMASK_6_KEY, NM_SSH_KEY_NETMASK_6, items, s_vpn)
-		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (PORT_KEY, NM_SSH_KEY_PORT, items, s_vpn, NM_SSH_DEFAULT_PORT)
-		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (MTU_KEY, NM_SSH_KEY_TUNNEL_MTU, items, s_vpn, NM_SSH_DEFAULT_MTU)
-		PARSE_IMPORT_KEY_WITH_DEFAULT_VALUE_INT (REMOTE_DEV_KEY, NM_SSH_KEY_REMOTE_DEV, items, s_vpn, NM_SSH_DEFAULT_REMOTE_DEV)
-		PARSE_IMPORT_KEY_BOOL (DEV_TYPE_KEY, NM_SSH_KEY_TAP_DEV, items, s_vpn, "tap")
-	}
-
-	if (connection)
-		nm_connection_add_setting (connection, NM_SETTING (s_vpn));
-	else if (s_vpn)
-		g_object_unref (s_vpn);
-
-out:
-	if (lines)
-		g_strfreev (lines);
-	g_free (contents);
-	return connection;
-}
-
-static gboolean
-export (NMVpnEditorPlugin *iface,
-        const char *path,
-        NMConnection *connection,
-        GError **error)
-{
-	NMSettingConnection *s_con;
-	NMSettingVpn *s_vpn;
-	FILE *f;
-	const char *value;
-	const char *auth_type = NULL;
-	const char *key_file = NULL;
-	const char *gateway = NULL;
-	const char *port = NULL;
-	const char *local_ip = NULL;
-	const char *remote_ip = NULL;
-	const char *netmask = NULL;
-	const char *local_ip_6 = NULL;
-	const char *remote_ip_6 = NULL;
-	const char *netmask_6 = NULL;
-	const char *remote_dev = NULL;
-	const char *mtu = NULL;
-	const char *remote_username = NULL;
-	char *device_type = NULL;
-	char *tunnel_type = NULL;
-	char *ifconfig_cmd_local_6 = NULL;
-	char *ifconfig_cmd_remote_6 = NULL;
-	char *preferred_authentication = NULL;
-	unsigned password_prompt_nr = 0;
-	gboolean ipv6 = FALSE;
-	gboolean success = FALSE;
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	g_assert (s_con);
-
-	s_vpn = (NMSettingVpn *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
-
-	f = fopen (path, "w");
-	if (!f) {
-		g_set_error (error, 0, 0, "could not open file for writing");
-		return FALSE;
-	}
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE);
-	if (value && strlen (value))
-		gateway = value;
-	else {
-		g_set_error (error, 0, 0, "connection was incomplete (missing gateway)");
-		goto done;
-	}
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP);
-	if (value && strlen (value))
-		remote_ip = value;
-	else {
-		g_set_error (error, 0, 0, "connection was incomplete (missing remote IP)");
-		goto done;
-	}
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP);
-	if (value && strlen (value))
-		local_ip = value;
-	else {
-		g_set_error (error, 0, 0, "connection was incomplete (missing local IP)");
-		goto done;
-	}
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK);
-	if (value && strlen (value))
-		netmask = value;
-	else {
-		g_set_error (error, 0, 0, "connection was incomplete (missing netmask)");
-		goto done;
-	}
-
-	/* Auth type */
-	auth_type = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_AUTH_TYPE);
-	if (auth_type) {
-		if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_PASSWORD, strlen(NM_SSH_AUTH_TYPE_PASSWORD))) {
-			password_prompt_nr = 1;
-			preferred_authentication = g_strdup("password");
-		} else if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_KEY, strlen(NM_SSH_AUTH_TYPE_KEY))) {
-			key_file = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_KEY_FILE);
-			preferred_authentication = g_strdup("publickey");
-		} else { // (!strncmp (auth_type, NM_SSH_AUTH_TYPE_SSH_AGENT, strlen(NM_SSH_AUTH_TYPE_SSH_AGENT))) {
-			// Nothing to be done for ssh-agent, the wise choice...
-			preferred_authentication = g_strdup("publickey");
-		}
-	}
-	/* Auth type */
-
-	/* Advanced values start */
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_PORT);
-	if (value && strlen (value))
-		port = value;
-	else
-		port = g_strdup_printf("%d", NM_SSH_DEFAULT_PORT);
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TUNNEL_MTU);
-	if (value && strlen (value))
-		mtu = value;
-	else
-		mtu = g_strdup_printf("%d", NM_SSH_DEFAULT_MTU);
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_DEV);
-	if (value && strlen (value))
-		remote_dev = value;
-	else
-		remote_dev = g_strdup_printf("%d", NM_SSH_DEFAULT_REMOTE_DEV);
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_USERNAME);
-	if (value && strlen (value))
-		remote_username = value;
-	else
-		remote_username = g_strdup(NM_SSH_DEFAULT_REMOTE_USERNAME);
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TAP_DEV);
-	if (value && IS_YES(value)) {
-		device_type = g_strdup("tap");
-		tunnel_type = g_strdup("ethernet");
-	} else {
-		device_type = g_strdup("tun");
-		tunnel_type = g_strdup("point-to-point");
-	}
-
-	value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_IP_6);
-	if (value && IS_YES(value)) {
-		ipv6 = TRUE;
-
-		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP_6);
-		if (value && strlen (value))
-			remote_ip_6 = value;
-		else {
-			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 remote IP)");
-			goto done;
-		}
-	
-		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP_6);
-		if (value && strlen (value))
-			local_ip_6 = value;
-		else {
-			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 local IP)");
-			goto done;
-		}
-
-		value = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK_6);
-		if (value && strlen (value))
-			netmask_6 = value;
-		else {
-			g_set_error (error, 0, 0, "connection was incomplete (missing IPv6 netmask)");
-			goto done;
-		}
-
-		ifconfig_cmd_local_6 = g_strdup_printf("%s $DEV_TYPE$LOCAL_DEV add $LOCAL_IP_6/$NETMASK_6", IFCONFIG);
-		ifconfig_cmd_remote_6 = g_strdup_printf("%s $DEV_TYPE$REMOTE_DEV add $REMOTE_IP_6/$NETMASK_6", IFCONFIG);
-	} else {
-		ipv6 = FALSE;
-		ifconfig_cmd_local_6 = g_strdup("");
-		ifconfig_cmd_remote_6 = g_strdup("");
-	}
-
-	/* Advanced values end */
-
-	/* Serialize everything to a file */
-	fprintf (f, "#!/bin/bash\n");
-	/* Make my life easier and just add the AUTH_TYPE= key, not used though */
-	fprintf (f, "%s=%s\n", AUTH_TYPE_KEY, auth_type);
-	if (key_file) {
-		fprintf (f, "%s=%s\n", KEY_FILE_KEY, key_file);
-	}
-	fprintf (f, "%s=%s\n", REMOTE_KEY, gateway);
-	fprintf (f, "%s=%s\n", REMOTE_USERNAME_KEY, remote_username);
-	fprintf (f, "%s=%s\n", REMOTE_IP_KEY, remote_ip);
-	fprintf (f, "%s=%s\n", LOCAL_IP_KEY, local_ip);
-	fprintf (f, "%s=%s\n", NETMASK_KEY, netmask);
-	if (ipv6) {
-		fprintf (f, "%s=%s\n", IP_6_KEY, YES);
-		fprintf (f, "%s=%s\n", REMOTE_IP_6_KEY, remote_ip_6);
-		fprintf (f, "%s=%s\n", LOCAL_IP_6_KEY, local_ip_6);
-		fprintf (f, "%s=%s\n", NETMASK_6_KEY, netmask_6);
-	}
-	fprintf (f, "%s=%s\n", PORT_KEY, port);
-	fprintf (f, "%s=%s\n", MTU_KEY, mtu);
-	fprintf (f, "%s=%s\n", REMOTE_DEV_KEY, remote_dev);
-
-	/* Assign tun/tap */
-	fprintf (f, "%s=%s\n", DEV_TYPE_KEY, device_type);
-	fprintf (f, "%s=%s\n", TUNNEL_TYPE_KEY, tunnel_type);
-
-	/* Add a little of bash script to probe for a free tun/tap device */
-	fprintf (f, "for i in `seq 0 255`; do ! %s $DEV_TYPE$i >& /dev/null && LOCAL_DEV=$i && break; done", IFCONFIG);
-
-	/* The generic lines that will perform the connection */
-	fprintf (f, "\n");
-	fprintf(f, "ssh -f %s -o PreferredAuthentications=%s -o NumberOfPasswordPrompts=%d -o Tunnel=$TUNNEL_TYPE -o ServerAliveInterval=10 -o TCPKeepAlive=yes -o TunnelDevice=$LOCAL_DEV:$REMOTE_DEV -o User=$REMOTE_USERNAME -o Port=$PORT -o HostName=$REMOTE $REMOTE \"%s $DEV_TYPE$REMOTE_DEV $REMOTE_IP netmask $NETMASK pointopoint $LOCAL_IP; %s\" && \\\n",
-		(key_file ? g_strconcat("-i ", key_file, NULL) : ""),
-		preferred_authentication,
-		password_prompt_nr,
-		IFCONFIG,
-		ifconfig_cmd_remote_6);
-	fprintf(f, "%s $DEV_TYPE$LOCAL_DEV $LOCAL_IP netmask $NETMASK pointopoint $REMOTE_IP; %s\n", IFCONFIG, ifconfig_cmd_local_6);
-
-	success = TRUE;
-
-	g_free(device_type);
-	g_free(tunnel_type);
-	g_free(ifconfig_cmd_local_6);
-	g_free(ifconfig_cmd_remote_6);
-	g_free(preferred_authentication);
-
-done:
-	fclose (f);
-	return success;
-}
-
-static char *
-get_suggested_filename (NMVpnEditorPlugin *iface, NMConnection *connection)
-{
-	NMSettingConnection *s_con;
-	const char *id;
-
-	g_return_val_if_fail (connection != NULL, NULL);
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	g_return_val_if_fail (s_con != NULL, NULL);
+/*****************************************************************************/
 
-	id = nm_setting_connection_get_id (s_con);
-	g_return_val_if_fail (id != NULL, NULL);
+#ifndef NM_VPN_OLD
 
-	return g_strdup_printf ("%s (ssh).sh", id);
-}
+#include "nm-ssh-editor-plugin.h"
 
-static guint32
-get_capabilities (NMVpnEditorPlugin *iface)
+G_MODULE_EXPORT NMVpnEditor *
+nm_vpn_editor_factory_ssh (NMVpnEditorPlugin *editor_plugin,
+                           NMConnection *connection,
+                           GError **error)
 {
-	return (NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT | NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT | NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6);
-}
+	g_return_val_if_fail (!error || !*error, NULL);
 
-static NMVpnEditor *
-get_editor (NMVpnEditorPlugin *iface, NMConnection *connection, GError **error)
-{
-	return nm_vpn_editor_interface_new (connection, error);
+	return nm_ssh_editor_new (connection, error);
 }
-
-static void
-get_property (GObject *object, guint prop_id,
-			  GValue *value, GParamSpec *pspec)
-{
-	switch (prop_id) {
-	case PROP_NAME:
-		g_value_set_string (value, SSH_PLUGIN_NAME);
-		break;
-	case PROP_DESC:
-		g_value_set_string (value, SSH_PLUGIN_DESC);
-		break;
-	case PROP_SERVICE:
-		g_value_set_string (value, SSH_PLUGIN_SERVICE);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-ssh_editor_plugin_class_init (SshEditorPluginClass *req_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
-
-	object_class->get_property = get_property;
-
-	g_object_class_override_property (object_class,
-									  PROP_NAME,
-									  NM_VPN_EDITOR_PLUGIN_NAME);
-
-	g_object_class_override_property (object_class,
-									  PROP_DESC,
-									  NM_VPN_EDITOR_PLUGIN_DESCRIPTION);
-
-	g_object_class_override_property (object_class,
-									  PROP_SERVICE,
-									  NM_VPN_EDITOR_PLUGIN_SERVICE);
-}
-
-static void
-ssh_editor_plugin_init (SshEditorPlugin *plugin)
-{
-}
-
-static void
-ssh_editor_plugin_interface_init (NMVpnEditorPluginInterface *iface_class)
-{
-	/* interface implementation */
-	iface_class->get_editor = get_editor;
-	iface_class->get_capabilities = get_capabilities;
-	iface_class->import_from_file = import;
-	iface_class->export_to_file = export;
-	iface_class->get_suggested_filename = get_suggested_filename;
-}
-
-G_MODULE_EXPORT NMVpnEditorPlugin *
-nm_vpn_editor_plugin_factory (GError **error)
-{
-	if (error)
-		g_return_val_if_fail (*error == NULL, NULL);
-
-	return g_object_new (SSH_TYPE_EDITOR_PLUGIN, NULL);
-}
-
+#endif
diff --git a/properties/nm-ssh-editor.h b/properties/nm-ssh-editor.h
new file mode 100644
index 0000000..dd6c6de
--- /dev/null
+++ b/properties/nm-ssh-editor.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/***************************************************************************
+ *
+ * Copyright (C) 2013 Dan Fruehauf, <malkodan@gmail.com>
+ * Copyright (C) 2022 Red Hat, Inc.
+ * Based on work by Dan Williams, <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ **************************************************************************/
+
+#ifndef _NM_SSH_EDITOR_H_
+#define _NM_SSH_EDITOR_H_
+
+#include <gtk/gtk.h>
+
+#if !GTK_CHECK_VERSION(4,0,0)
+#define gtk_editable_set_text(editable,text)		gtk_entry_set_text(GTK_ENTRY(editable), (text))
+#define gtk_editable_get_text(editable)			gtk_entry_get_text(GTK_ENTRY(editable))
+#define gtk_widget_get_root(widget)			gtk_widget_get_toplevel(widget)
+#define gtk_check_button_get_active(button)		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button))
+#define gtk_check_button_set_active(button, active)	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), active)
+#define gtk_window_destroy(window)			gtk_widget_destroy(GTK_WIDGET (window))
+#define gtk_window_set_hide_on_close(window, hide)						\
+	G_STMT_START {										\
+		G_STATIC_ASSERT(hide);								\
+		g_signal_connect_swapped (G_OBJECT (window), "delete-event",			\
+					  G_CALLBACK (gtk_widget_hide_on_delete), window);	\
+	} G_STMT_END
+
+typedef void GtkRoot;
+#endif
+
+#define SSH_TYPE_EDITOR            (ssh_editor_get_type ())
+#define SSH_EDITOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), SSH_TYPE_EDITOR, SshEditor))
+#define SSH_EDITOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), SSH_TYPE_EDITOR, SshEditorClass))
+#define SSH_IS_EDITOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SSH_TYPE_EDITOR))
+#define SSH_IS_EDITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), SSH_TYPE_EDITOR))
+#define SSH_EDITOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), SSH_TYPE_EDITOR, SshEditorClass))
+
+typedef struct _SshEditor SshEditor;
+typedef struct _SshEditorClass SshEditorClass;
+
+struct _SshEditor {
+	GObject parent;
+};
+
+struct _SshEditorClass {
+	GObjectClass parent;
+};
+
+GType ssh_editor_get_type (void);
+
+NMVpnEditor *nm_ssh_editor_new (NMConnection *connection, GError **error);
+
+#endif	/* _NM_SSH_EDITOR_H_ */
diff --git a/shared/README b/shared/README
new file mode 100644
index 0000000..3fe41ef
--- /dev/null
+++ b/shared/README
@@ -0,0 +1,9 @@
+The files in the "shared/" directory are used by all components
+inside the VPN plugin repository (src, properties, auth-dialog).
+
+The files in shared/nm-utils are copied from NetworkManager
+repository and used as is:
+Do *not* modify these files locally so that they don't diverge
+from their original. Fix/extend them in their respective origin
+first, and re-import the files as a whole.
+
diff --git a/shared/nm-default.h b/shared/nm-default.h
new file mode 100644
index 0000000..139dc74
--- /dev/null
+++ b/shared/nm-default.h
@@ -0,0 +1,118 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2015 Red Hat, Inc.
+ */
+
+#ifndef __NM_DEFAULT_H__
+#define __NM_DEFAULT_H__
+
+/* makefiles define NETWORKMANAGER_COMPILATION for compiling NetworkManager.
+ * Depending on which parts are compiled, different values are set. */
+#define NM_NETWORKMANAGER_COMPILATION_DEFAULT             0x0001
+#define NM_NETWORKMANAGER_COMPILATION_LIB_BASE            0x0002
+#define NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR          0x0004
+#define NM_NETWORKMANAGER_COMPILATION_LIB                 (0x0002 | 0x0004)
+
+#ifndef NETWORKMANAGER_COMPILATION
+/* For convenience, we don't require our Makefile.am to define
+ * -DNETWORKMANAGER_COMPILATION. As we now include this internal header,
+ *  we know we do a NETWORKMANAGER_COMPILATION. */
+#define NETWORKMANAGER_COMPILATION NM_NETWORKMANAGER_COMPILATION_DEFAULT
+#endif
+
+/*****************************************************************************/
+
+#include <config.h>
+
+/* always include these headers for our internal source files. */
+
+#include "nm-utils/nm-glib.h"
+#include "nm-utils/gsystem-local-alloc.h"
+#include "nm-utils/nm-macros-internal.h"
+
+#include "nm-version.h"
+#include "nm-service-defines.h"
+
+/*****************************************************************************/
+
+#if ((NETWORKMANAGER_COMPILATION) & NM_NETWORKMANAGER_COMPILATION_LIB)
+
+#include <glib/gi18n-lib.h>
+
+#else
+
+#include <glib/gi18n.h>
+
+#endif /* NM_NETWORKMANAGER_COMPILATION_LIB */
+
+/*****************************************************************************/
+
+#ifdef NM_VPN_OLD
+
+#define NM_VPN_LIBNM_COMPAT
+#include <nm-connection.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-8021x.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-setting-vpn.h>
+#include <nm-utils.h>
+#include <nm-vpn-plugin-ui-interface.h>
+
+#define nm_simple_connection_new nm_connection_new
+#define NM_SETTING_IP_CONFIG NM_SETTING_IP4_CONFIG
+#define NM_SETTING_IP_CONFIG_METHOD NM_SETTING_IP4_CONFIG_METHOD
+#define NMSettingIPConfig NMSettingIP4Config
+
+#define NMV_EDITOR_PLUGIN_ERROR                     NM_SETTING_VPN_ERROR
+#define NMV_EDITOR_PLUGIN_ERROR_FAILED              NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_SETTING_VPN_ERROR_INVALID_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_SETTING_VPN_ERROR_MISSING_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN        NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_SETTING_VPN_ERROR_UNKNOWN
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_SETTING_VPN_ERROR_UNKNOWN
+
+#else /* !NM_VPN_OLD */
+
+#include <NetworkManager.h>
+
+#define NMV_EDITOR_PLUGIN_ERROR                     NM_CONNECTION_ERROR
+#define NMV_EDITOR_PLUGIN_ERROR_FAILED              NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_INVALID_PROPERTY    NM_CONNECTION_ERROR_INVALID_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_MISSING_PROPERTY    NM_CONNECTION_ERROR_MISSING_PROPERTY
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_VPN        NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_NOT_READABLE   NM_CONNECTION_ERROR_FAILED
+#define NMV_EDITOR_PLUGIN_ERROR_FILE_INVALID        NM_CONNECTION_ERROR_FAILED
+
+#endif /* NM_VPN_OLD */
+
+/*****************************************************************************/
+
+#if (NETWORKMANAGER_COMPILATION) & NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR
+
+#ifdef NM_VPN_OLD
+#include <nm-ui-utils.h>
+#else /* NM_VPN_OLD */
+#include <nma-ui-utils.h>
+#endif /* NM_VPN_OLD */
+
+#endif /* NM_NETWORKMANAGER_COMPILATION_LIB_EDITOR */
+
+/*****************************************************************************/
+
+#endif /* __NM_DEFAULT_H__ */
diff --git a/src/nm-ssh-service-defines.h b/shared/nm-service-defines.h
similarity index 100%
rename from src/nm-ssh-service-defines.h
rename to shared/nm-service-defines.h
diff --git a/shared/nm-utils/gsystem-local-alloc.h b/shared/nm-utils/gsystem-local-alloc.h
new file mode 100644
index 0000000..51b6251
--- /dev/null
+++ b/shared/nm-utils/gsystem-local-alloc.h
@@ -0,0 +1,208 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*-
+ *
+ * Copyright (C) 2012 Colin Walters <walters@verbum.org>.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSYSTEM_LOCAL_ALLOC_H__
+#define __GSYSTEM_LOCAL_ALLOC_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define GS_DEFINE_CLEANUP_FUNCTION(Type, name, func) \
+  static inline void name (void *v) \
+  { \
+    func (*(Type*)v); \
+  }
+
+#define GS_DEFINE_CLEANUP_FUNCTION0(Type, name, func) \
+  static inline void name (void *v) \
+  { \
+    if (*(Type*)v) \
+      func (*(Type*)v); \
+  }
+
+/* These functions shouldn't be invoked directly;
+ * they are stubs that:
+ * 1) Take a pointer to the location (typically itself a pointer).
+ * 2) Provide %NULL-safety where it doesn't exist already (e.g. g_object_unref)
+ */
+
+/**
+ * gs_free:
+ *
+ * Call g_free() on a variable location when it goes out of scope.
+ */
+#define gs_free __attribute__ ((cleanup(gs_local_free)))
+GS_DEFINE_CLEANUP_FUNCTION(void*, gs_local_free, g_free)
+
+/**
+ * gs_unref_object:
+ *
+ * Call g_object_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_object_unref(), the variable may be
+ * %NULL.
+ */
+#define gs_unref_object __attribute__ ((cleanup(gs_local_obj_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GObject*, gs_local_obj_unref, g_object_unref)
+
+/**
+ * gs_unref_variant:
+ *
+ * Call g_variant_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_variant_unref(), the variable may be
+ * %NULL.
+ */
+#define gs_unref_variant __attribute__ ((cleanup(gs_local_variant_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariant*, gs_local_variant_unref, g_variant_unref)
+
+/**
+ * gs_free_variant_iter:
+ *
+ * Call g_variant_iter_free() on a variable location when it goes out of
+ * scope.
+ */
+#define gs_free_variant_iter __attribute__ ((cleanup(gs_local_variant_iter_free)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariantIter*, gs_local_variant_iter_free, g_variant_iter_free)
+
+/**
+ * gs_free_variant_builder:
+ *
+ * Call g_variant_builder_unref() on a variable location when it goes out of
+ * scope.
+ */
+#define gs_unref_variant_builder __attribute__ ((cleanup(gs_local_variant_builder_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GVariantBuilder*, gs_local_variant_builder_unref, g_variant_builder_unref)
+
+/**
+ * gs_unref_array:
+ *
+ * Call g_array_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_array_unref(), the variable may be
+ * %NULL.
+
+ */
+#define gs_unref_array __attribute__ ((cleanup(gs_local_array_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GArray*, gs_local_array_unref, g_array_unref)
+
+/**
+ * gs_unref_ptrarray:
+ *
+ * Call g_ptr_array_unref() on a variable location when it goes out of
+ * scope.  Note that unlike g_ptr_array_unref(), the variable may be
+ * %NULL.
+
+ */
+#define gs_unref_ptrarray __attribute__ ((cleanup(gs_local_ptrarray_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GPtrArray*, gs_local_ptrarray_unref, g_ptr_array_unref)
+
+/**
+ * gs_unref_hashtable:
+ *
+ * Call g_hash_table_unref() on a variable location when it goes out
+ * of scope.  Note that unlike g_hash_table_unref(), the variable may
+ * be %NULL.
+ */
+#define gs_unref_hashtable __attribute__ ((cleanup(gs_local_hashtable_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GHashTable*, gs_local_hashtable_unref, g_hash_table_unref)
+
+/**
+ * gs_free_list:
+ *
+ * Call g_list_free() on a variable location when it goes out
+ * of scope.
+ */
+#define gs_free_list __attribute__ ((cleanup(gs_local_free_list)))
+GS_DEFINE_CLEANUP_FUNCTION(GList*, gs_local_free_list, g_list_free)
+
+/**
+ * gs_free_slist:
+ *
+ * Call g_slist_free() on a variable location when it goes out
+ * of scope.
+ */
+#define gs_free_slist __attribute__ ((cleanup(gs_local_free_slist)))
+GS_DEFINE_CLEANUP_FUNCTION(GSList*, gs_local_free_slist, g_slist_free)
+
+/**
+ * gs_free_checksum:
+ *
+ * Call g_checksum_free() on a variable location when it goes out
+ * of scope.  Note that unlike g_checksum_free(), the variable may
+ * be %NULL.
+ */
+#define gs_free_checksum __attribute__ ((cleanup(gs_local_checksum_free)))
+GS_DEFINE_CLEANUP_FUNCTION0(GChecksum*, gs_local_checksum_free, g_checksum_free)
+
+/**
+ * gs_unref_bytes:
+ *
+ * Call g_bytes_unref() on a variable location when it goes out
+ * of scope.  Note that unlike g_bytes_unref(), the variable may
+ * be %NULL.
+ */
+#define gs_unref_bytes __attribute__ ((cleanup(gs_local_bytes_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GBytes*, gs_local_bytes_unref, g_bytes_unref)
+
+/**
+ * gs_strfreev:
+ *
+ * Call g_strfreev() on a variable location when it goes out of scope.
+ */
+#define gs_strfreev __attribute__ ((cleanup(gs_local_strfreev)))
+GS_DEFINE_CLEANUP_FUNCTION(char**, gs_local_strfreev, g_strfreev)
+
+/**
+ * gs_free_error:
+ *
+ * Call g_error_free() on a variable location when it goes out of scope.
+ */
+#define gs_free_error __attribute__ ((cleanup(gs_local_free_error)))
+GS_DEFINE_CLEANUP_FUNCTION0(GError*, gs_local_free_error, g_error_free)
+
+/**
+ * gs_unref_keyfile:
+ *
+ * Call g_key_file_unref() on a variable location when it goes out of scope.
+ */
+#define gs_unref_keyfile __attribute__ ((cleanup(gs_local_keyfile_unref)))
+GS_DEFINE_CLEANUP_FUNCTION0(GKeyFile*, gs_local_keyfile_unref, g_key_file_unref)
+
+static inline void
+gs_cleanup_close_fdp (int *fdp)
+{
+  int fd;
+
+  g_assert (fdp);
+  
+  fd = *fdp;
+  if (fd != -1)
+    (void) close (fd);
+}
+
+/**
+ * gs_fd_close:
+ *
+ * Call close() on a variable location when it goes out of scope.
+ */
+#define gs_fd_close __attribute__((cleanup(gs_cleanup_close_fdp)))
+
+G_END_DECLS
+
+#endif
diff --git a/shared/nm-utils/nm-glib.h b/shared/nm-utils/nm-glib.h
new file mode 100644
index 0000000..824a08c
--- /dev/null
+++ b/shared/nm-utils/nm-glib.h
@@ -0,0 +1,452 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2008 - 2011 Red Hat, Inc.
+ */
+
+#ifndef __NM_GLIB_H__
+#define __NM_GLIB_H__
+
+
+#include <gio/gio.h>
+#include <string.h>
+
+#include "gsystem-local-alloc.h"
+
+#ifdef __clang__
+
+#undef G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+#undef G_GNUC_END_IGNORE_DEPRECATIONS
+
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+    _Pragma("clang diagnostic push") \
+    _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+
+#define G_GNUC_END_IGNORE_DEPRECATIONS \
+    _Pragma("clang diagnostic pop")
+
+#endif
+
+static inline void
+__g_type_ensure (GType type)
+{
+#if !GLIB_CHECK_VERSION(2,34,0)
+	if (G_UNLIKELY (type == (GType)-1))
+		g_error ("can't happen");
+#else
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS;
+	g_type_ensure (type);
+	G_GNUC_END_IGNORE_DEPRECATIONS;
+#endif
+}
+#define g_type_ensure __g_type_ensure
+
+#if !GLIB_CHECK_VERSION(2,34,0)
+
+#define g_clear_pointer(pp, destroy) \
+    G_STMT_START {                                                                 \
+        G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
+        /* Only one access, please */                                              \
+        gpointer *_pp = (gpointer *) (pp);                                         \
+        gpointer _p;                                                               \
+        /* This assignment is needed to avoid a gcc warning */                     \
+        GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
+                                                                                   \
+        _p = *_pp;                                                                 \
+        if (_p)                                                                    \
+        {                                                                          \
+            *_pp = NULL;                                                           \
+            _destroy (_p);                                                         \
+        }                                                                          \
+    } G_STMT_END
+
+/* These are used to clean up the output of test programs; we can just let
+ * them no-op in older glib.
+ */
+#define g_test_expect_message(log_domain, log_level, pattern)
+#define g_test_assert_expected_messages()
+
+#else
+
+/* We build with -DGLIB_MAX_ALLOWED_VERSION set to 2.32 to make sure we don't
+ * accidentally use new API that we shouldn't. But we don't want warnings for
+ * the APIs that we emulate above.
+ */
+
+#define g_test_expect_message(domain, level, format...) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_expect_message (domain, level, format); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+
+#define g_test_assert_expected_messages_internal(domain, file, line, func) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_assert_expected_messages_internal (domain, file, line, func); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+
+#endif
+
+
+#if GLIB_CHECK_VERSION (2, 35, 0)
+/* For glib >= 2.36, g_type_init() is deprecated.
+ * But since 2.35.1 (7c42ab23b55c43ab96d0ac2124b550bf1f49c1ec) this function
+ * does nothing. Replace the call with empty statement. */
+#define nm_g_type_init()     G_STMT_START { (void) 0; } G_STMT_END
+#else
+#define nm_g_type_init()     G_STMT_START { g_type_init (); } G_STMT_END
+#endif
+
+
+/* g_test_initialized() is only available since glib 2.36. */
+#if !GLIB_CHECK_VERSION (2, 36, 0)
+#define g_test_initialized() (g_test_config_vars->test_initialized)
+#endif
+
+/* g_assert_cmpmem() is only available since glib 2.46. */
+#if !GLIB_CHECK_VERSION (2, 45, 7)
+#define g_assert_cmpmem(m1, l1, m2, l2) G_STMT_START {\
+                                             gconstpointer __m1 = m1, __m2 = m2; \
+                                             int __l1 = l1, __l2 = l2; \
+                                             if (__l1 != __l2) \
+                                               g_assertion_message_cmpnum (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
+                                                                           #l1 " (len(" #m1 ")) == " #l2 " (len(" #m2 "))", __l1, "==", __l2, 'i'); \
+                                             else if (memcmp (__m1, __m2, __l1) != 0) \
+                                               g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, \
+                                                                    "assertion failed (" #m1 " == " #m2 ")"); \
+                                        } G_STMT_END
+#endif
+
+/* Rumtime check for glib version. First do a compile time check which
+ * (if satisfied) shortcuts the runtime check. */
+#define nm_glib_check_version(major, minor, micro) \
+    (   GLIB_CHECK_VERSION ((major), (minor), (micro)) \
+     || (   (   glib_major_version > (major)) \
+         || (   glib_major_version == (major) \
+             && glib_minor_version > (minor)) \
+         || (   glib_major_version == (major) \
+             && glib_minor_version == (minor) \
+             && glib_micro_version >= (micro))))
+
+/* g_test_skip() is only available since glib 2.38. Add a compatibility wrapper. */
+inline static void
+__nmtst_g_test_skip (const gchar *msg)
+{
+#if GLIB_CHECK_VERSION (2, 38, 0)
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	g_test_skip (msg);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#else
+	g_debug ("%s", msg);
+#endif
+}
+#define g_test_skip __nmtst_g_test_skip
+
+
+/* g_test_add_data_func_full() is only available since glib 2.34. Add a compatibility wrapper. */
+inline static void
+__g_test_add_data_func_full (const char     *testpath,
+                             gpointer        test_data,
+                             GTestDataFunc   test_func,
+                             GDestroyNotify  data_free_func)
+{
+#if GLIB_CHECK_VERSION (2, 34, 0)
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	g_test_add_data_func_full (testpath, test_data, test_func, data_free_func);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#else
+	g_return_if_fail (testpath != NULL);
+	g_return_if_fail (testpath[0] == '/');
+	g_return_if_fail (test_func != NULL);
+
+	g_test_add_vtable (testpath, 0, test_data, NULL,
+	                   (GTestFixtureFunc) test_func,
+	                   (GTestFixtureFunc) data_free_func);
+#endif
+}
+#define g_test_add_data_func_full __g_test_add_data_func_full
+
+
+#if !GLIB_CHECK_VERSION (2, 34, 0)
+#define G_DEFINE_QUARK(QN, q_n)               \
+GQuark                                        \
+q_n##_quark (void)                            \
+{                                             \
+	static GQuark q;                          \
+                                              \
+	if G_UNLIKELY (q == 0)                    \
+		q = g_quark_from_static_string (#QN); \
+                                              \
+	return q;                                 \
+}
+#endif
+
+
+static inline gboolean
+nm_g_hash_table_replace (GHashTable *hash, gpointer key, gpointer value)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_replace (hash, key, value);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_replace (hash, key, value);
+	return !contained;
+#endif
+}
+
+static inline gboolean
+nm_g_hash_table_insert (GHashTable *hash, gpointer key, gpointer value)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_insert (hash, key, value);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_insert (hash, key, value);
+	return !contained;
+#endif
+}
+
+static inline gboolean
+nm_g_hash_table_add (GHashTable *hash, gpointer key)
+{
+	/* glib 2.40 added a return value indicating whether the key already existed
+	 * (910191597a6c2e5d5d460e9ce9efb4f47d9cc63c). */
+#if GLIB_CHECK_VERSION(2, 40, 0)
+	return g_hash_table_add (hash, key);
+#else
+	gboolean contained = g_hash_table_contains (hash, key);
+
+	g_hash_table_add (hash, key);
+	return !contained;
+#endif
+}
+
+#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
+static inline void
+_nm_g_ptr_array_insert (GPtrArray *array,
+                        gint       index_,
+                        gpointer   data)
+{
+	g_return_if_fail (array);
+	g_return_if_fail (index_ >= -1);
+	g_return_if_fail (index_ <= (gint) array->len);
+
+	g_ptr_array_add (array, data);
+
+	if (index_ != -1 && index_ != (gint) (array->len - 1)) {
+		memmove (&(array->pdata[index_ + 1]),
+		         &(array->pdata[index_]),
+		         (array->len - index_ - 1) * sizeof (gpointer));
+		array->pdata[index_] = data;
+	}
+}
+#endif
+#if !GLIB_CHECK_VERSION(2, 40, 0)
+#define g_ptr_array_insert(array, index, data) G_STMT_START { _nm_g_ptr_array_insert (array, index, data); } G_STMT_END
+#else
+#define g_ptr_array_insert(array, index, data) \
+	G_STMT_START { \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_ptr_array_insert (array, index, data); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+#endif
+
+
+#if !GLIB_CHECK_VERSION (2, 40, 0)
+inline static gboolean
+_g_key_file_save_to_file (GKeyFile     *key_file,
+                          const gchar  *filename,
+                          GError      **error)
+{
+	gchar *contents;
+	gboolean success;
+	gsize length;
+
+	g_return_val_if_fail (key_file != NULL, FALSE);
+	g_return_val_if_fail (filename != NULL, FALSE);
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	contents = g_key_file_to_data (key_file, &length, NULL);
+	g_assert (contents != NULL);
+
+	success = g_file_set_contents (filename, contents, length, error);
+	g_free (contents);
+
+	return success;
+}
+#define g_key_file_save_to_file(key_file, filename, error) \
+	_g_key_file_save_to_file (key_file, filename, error)
+#else
+#define g_key_file_save_to_file(key_file, filename, error) \
+	({ \
+		gboolean _success; \
+		\
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		_success = g_key_file_save_to_file (key_file, filename, error); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+		_success; \
+	})
+#endif
+
+
+#if GLIB_CHECK_VERSION (2, 36, 0)
+#define g_credentials_get_unix_pid(creds, error) \
+	({ \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			(g_credentials_get_unix_pid) ((creds), (error)); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	})
+#else
+#define g_credentials_get_unix_pid(creds, error) \
+	({ \
+		struct ucred *native_creds; \
+		 \
+		native_creds = g_credentials_get_native ((creds), G_CREDENTIALS_TYPE_LINUX_UCRED); \
+		g_assert (native_creds); \
+		native_creds->pid; \
+	})
+#endif
+
+
+#if !GLIB_CHECK_VERSION(2, 40, 0) || defined (NM_GLIB_COMPAT_H_TEST)
+static inline gpointer *
+_nm_g_hash_table_get_keys_as_array (GHashTable *hash_table,
+                                    guint      *length)
+{
+	GHashTableIter iter;
+	gpointer key, *ret;
+	guint i = 0;
+
+	g_return_val_if_fail (hash_table, NULL);
+
+	ret = g_new0 (gpointer, g_hash_table_size (hash_table) + 1);
+	g_hash_table_iter_init (&iter, hash_table);
+
+	while (g_hash_table_iter_next (&iter, &key, NULL))
+		ret[i++] = key;
+
+	ret[i] = NULL;
+
+	if (length)
+		*length = i;
+
+	return ret;
+}
+#endif
+#if !GLIB_CHECK_VERSION(2, 40, 0)
+#define g_hash_table_get_keys_as_array(hash_table, length) \
+	({ \
+		_nm_g_hash_table_get_keys_as_array (hash_table, length); \
+	})
+#else
+#define g_hash_table_get_keys_as_array(hash_table, length) \
+	({ \
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			(g_hash_table_get_keys_as_array) ((hash_table), (length)); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	})
+#endif
+
+#ifndef g_info
+/* g_info was only added with 2.39.2 */
+#define g_info(...)     g_log (G_LOG_DOMAIN,         \
+                               G_LOG_LEVEL_INFO,     \
+                               __VA_ARGS__)
+#endif
+
+#if !GLIB_CHECK_VERSION(2, 44, 0)
+static inline gpointer
+g_steal_pointer (gpointer pp)
+{
+	gpointer *ptr = (gpointer *) pp;
+	gpointer ref;
+
+	ref = *ptr;
+	*ptr = NULL;
+
+	return ref;
+}
+
+/* type safety */
+#define g_steal_pointer(pp) \
+  (0 ? (*(pp)) : (g_steal_pointer) (pp))
+#endif
+
+
+static inline gboolean
+_nm_g_strv_contains (const gchar * const *strv,
+                     const gchar         *str)
+{
+#if !GLIB_CHECK_VERSION(2, 44, 0)
+	g_return_val_if_fail (strv != NULL, FALSE);
+	g_return_val_if_fail (str != NULL, FALSE);
+
+	for (; *strv != NULL; strv++) {
+		if (g_str_equal (str, *strv))
+			return TRUE;
+	}
+
+	return FALSE;
+#else
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	return g_strv_contains (strv, str);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#endif
+}
+#define g_strv_contains _nm_g_strv_contains
+
+static inline GVariant *
+_nm_g_variant_new_take_string (gchar *string)
+{
+#if !GLIB_CHECK_VERSION(2, 36, 0)
+	GVariant *value;
+
+	g_return_val_if_fail (string != NULL, NULL);
+	g_return_val_if_fail (g_utf8_validate (string, -1, NULL), NULL);
+
+	value = g_variant_new_string (string);
+	g_free (string);
+	return value;
+#elif !GLIB_CHECK_VERSION(2, 38, 0)
+	GVariant *value;
+	GBytes *bytes;
+
+	g_return_val_if_fail (string != NULL, NULL);
+	g_return_val_if_fail (g_utf8_validate (string, -1, NULL), NULL);
+
+	bytes = g_bytes_new_take (string, strlen (string) + 1);
+	value = g_variant_new_from_bytes (G_VARIANT_TYPE_STRING, bytes, TRUE);
+	g_bytes_unref (bytes);
+
+	return value;
+#else
+	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+	return g_variant_new_take_string (string);
+	G_GNUC_END_IGNORE_DEPRECATIONS
+#endif
+}
+#define g_variant_new_take_string _nm_g_variant_new_take_string
+
+#endif  /* __NM_GLIB_H__ */
diff --git a/shared/nm-utils/nm-macros-internal.h b/shared/nm-utils/nm-macros-internal.h
new file mode 100644
index 0000000..70476b7
--- /dev/null
+++ b/shared/nm-utils/nm-macros-internal.h
@@ -0,0 +1,876 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef __NM_MACROS_INTERNAL_H__
+#define __NM_MACROS_INTERNAL_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include "nm-glib.h"
+
+/*****************************************************************************/
+
+#define _nm_packed __attribute__ ((packed))
+#define _nm_unused __attribute__ ((unused))
+#define _nm_pure   __attribute__ ((pure))
+#define _nm_const  __attribute__ ((const))
+#define _nm_printf(a,b) __attribute__ ((__format__ (__printf__, a, b)))
+
+#define nm_offsetofend(t,m) (G_STRUCT_OFFSET (t,m) + sizeof (((t *) NULL)->m))
+
+#define nm_auto(fcn) __attribute__ ((cleanup(fcn)))
+
+/**
+ * nm_auto_free:
+ *
+ * Call free() on a variable location when it goes out of scope.
+ */
+#define nm_auto_free nm_auto(_nm_auto_free_impl)
+GS_DEFINE_CLEANUP_FUNCTION(void*, _nm_auto_free_impl, free)
+
+static inline void
+_nm_auto_unset_gvalue_impl (GValue *v)
+{
+	g_value_unset (v);
+}
+#define nm_auto_unset_gvalue nm_auto(_nm_auto_unset_gvalue_impl)
+
+static inline void
+_nm_auto_free_gstring_impl (GString **str)
+{
+	if (*str)
+		g_string_free (*str, TRUE);
+}
+#define nm_auto_free_gstring nm_auto(_nm_auto_free_gstring_impl)
+
+static inline void
+_nm_auto_close_impl (int *pfd)
+{
+	if (*pfd >= 0) {
+		int errsv = errno;
+
+		(void) close (*pfd);
+		errno = errsv;
+	}
+}
+#define nm_auto_close nm_auto(_nm_auto_close_impl)
+
+static inline void
+_nm_auto_fclose_impl (FILE **pfd)
+{
+	if (*pfd) {
+		int errsv = errno;
+
+		(void) fclose (*pfd);
+		errno = errsv;
+	}
+}
+#define nm_auto_fclose nm_auto(_nm_auto_fclose_impl)
+
+static inline void
+_nm_auto_protect_errno (int *p_saved_errno)
+{
+	errno = *p_saved_errno;
+}
+#define NM_AUTO_PROTECT_ERRNO(errsv_saved) nm_auto(_nm_auto_protect_errno) _nm_unused const int errsv_saved = (errno)
+
+/*****************************************************************************/
+
+/* http://stackoverflow.com/a/11172679 */
+#define  _NM_UTILS_MACRO_FIRST(...)                           __NM_UTILS_MACRO_FIRST_HELPER(__VA_ARGS__, throwaway)
+#define __NM_UTILS_MACRO_FIRST_HELPER(first, ...)             first
+
+#define  _NM_UTILS_MACRO_REST(...)                            __NM_UTILS_MACRO_REST_HELPER(__NM_UTILS_MACRO_REST_NUM(__VA_ARGS__), __VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER(qty, ...)                __NM_UTILS_MACRO_REST_HELPER2(qty, __VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER2(qty, ...)               __NM_UTILS_MACRO_REST_HELPER_##qty(__VA_ARGS__)
+#define __NM_UTILS_MACRO_REST_HELPER_ONE(first)
+#define __NM_UTILS_MACRO_REST_HELPER_TWOORMORE(first, ...)    , __VA_ARGS__
+#define __NM_UTILS_MACRO_REST_NUM(...) \
+    __NM_UTILS_MACRO_REST_SELECT_20TH(__VA_ARGS__, \
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\
+                TWOORMORE, TWOORMORE, TWOORMORE, ONE, throwaway)
+#define __NM_UTILS_MACRO_REST_SELECT_20TH(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, ...) a20
+
+/*****************************************************************************/
+
+/* http://stackoverflow.com/a/2124385/354393 */
+
+#define NM_NARG(...) \
+         _NM_NARG(__VA_ARGS__,_NM_NARG_RSEQ_N())
+#define _NM_NARG(...) \
+         _NM_NARG_ARG_N(__VA_ARGS__)
+#define _NM_NARG_ARG_N( \
+          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
+         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
+         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
+         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
+         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
+         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
+         _61,_62,_63,N,...) N
+#define _NM_NARG_RSEQ_N() \
+         63,62,61,60,                   \
+         59,58,57,56,55,54,53,52,51,50, \
+         49,48,47,46,45,44,43,42,41,40, \
+         39,38,37,36,35,34,33,32,31,30, \
+         29,28,27,26,25,24,23,22,21,20, \
+         19,18,17,16,15,14,13,12,11,10, \
+         9,8,7,6,5,4,3,2,1,0
+
+/*****************************************************************************/
+
+#if defined (__GNUC__)
+#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(GCC diagnostic ignored warning)
+#elif defined (__clang__)
+#define _NM_PRAGMA_WARNING_DO(warning)       G_STRINGIFY(clang diagnostic ignored warning)
+#endif
+
+/* you can only suppress a specific warning that the compiler
+ * understands. Otherwise you will get another compiler warning
+ * about invalid pragma option.
+ * It's not that bad however, because gcc and clang often have the
+ * same name for the same warning. */
+
+#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define NM_PRAGMA_WARNING_DISABLE(warning) \
+        _Pragma("GCC diagnostic push") \
+        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
+#elif defined (__clang__)
+#define NM_PRAGMA_WARNING_DISABLE(warning) \
+        _Pragma("clang diagnostic push") \
+        _Pragma(_NM_PRAGMA_WARNING_DO(warning))
+#else
+#define NM_PRAGMA_WARNING_DISABLE(warning)
+#endif
+
+#if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
+#define NM_PRAGMA_WARNING_REENABLE \
+    _Pragma("GCC diagnostic pop")
+#elif defined (__clang__)
+#define NM_PRAGMA_WARNING_REENABLE \
+    _Pragma("clang diagnostic pop")
+#else
+#define NM_PRAGMA_WARNING_REENABLE
+#endif
+
+/*****************************************************************************/
+
+/**
+ * NM_G_ERROR_MSG:
+ * @error: (allow none): the #GError instance
+ *
+ * All functions must follow the convention that when they
+ * return a failure, they must also set the GError to a valid
+ * message. For external API however, we want to be extra
+ * careful before accessing the error instance. Use NM_G_ERROR_MSG()
+ * which is safe to use on NULL.
+ *
+ * Returns: the error message.
+ **/
+static inline const char *
+NM_G_ERROR_MSG (GError *error)
+{
+	return error ? (error->message ? : "(null)") : "(no-error)"; \
+}
+
+/*****************************************************************************/
+
+/* macro to return strlen() of a compile time string. */
+#define NM_STRLEN(str)     ( sizeof ("" str) - 1 )
+
+/* Note: @value is only evaluated when *out_val is present.
+ * Thus,
+ *    NM_SET_OUT (out_str, g_strdup ("hallo"));
+ * does the right thing.
+ */
+#define NM_SET_OUT(out_val, value) \
+	G_STMT_START { \
+		typeof(*(out_val)) *_out_val = (out_val); \
+		\
+		if (_out_val) { \
+			*_out_val = (value); \
+		} \
+	} G_STMT_END
+
+/*****************************************************************************/
+
+#define _NM_IN_SET_EVAL_1( op, _x, y)           (_x == (y))
+#define _NM_IN_SET_EVAL_2( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_1  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_3( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_2  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_4( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_3  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_5( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_4  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_6( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_5  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_7( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_6  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_8( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_7  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_9( op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_8  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_10(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_9  (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_11(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_10 (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_12(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_11 (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_13(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_12 (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_14(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_13 (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_15(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_14 (op, _x, __VA_ARGS__)
+#define _NM_IN_SET_EVAL_16(op, _x, y, ...)      (_x == (y)) op _NM_IN_SET_EVAL_15 (op, _x, __VA_ARGS__)
+
+#define _NM_IN_SET_EVAL_N2(op, _x, n, ...)      (_NM_IN_SET_EVAL_##n(op, _x, __VA_ARGS__))
+#define _NM_IN_SET_EVAL_N(op, x, n, ...)                            \
+    ({                                                              \
+        typeof(x) _x = (x);                                         \
+        !!_NM_IN_SET_EVAL_N2(op, _x, n, __VA_ARGS__);               \
+    })
+
+/* Beware that this does short-circuit evaluation (use "||" instead of "|")
+ * which has a possibly unexpected non-function-like behavior.
+ * Use NM_IN_SET_SE if you need all arguments to be evaluted. */
+#define NM_IN_SET(x, ...)               _NM_IN_SET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/* "SE" stands for "side-effect". Contrary to NM_IN_SET(), this does not do
+ * short-circuit evaluation, which can make a difference if the arguments have
+ * side-effects. */
+#define NM_IN_SET_SE(x, ...)            _NM_IN_SET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/*****************************************************************************/
+
+static inline gboolean
+_NM_IN_STRSET_streq (const char *x, const char *s)
+{
+	return s && strcmp (x, s) == 0;
+}
+
+#define _NM_IN_STRSET_EVAL_1( op, _x, y)        _NM_IN_STRSET_streq (_x, y)
+#define _NM_IN_STRSET_EVAL_2( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_1  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_3( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_2  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_4( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_3  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_5( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_4  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_6( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_5  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_7( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_6  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_8( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_7  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_9( op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_8  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_10(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_9  (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_11(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_10 (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_12(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_11 (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_13(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_12 (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_14(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_13 (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_15(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_14 (op, _x, __VA_ARGS__)
+#define _NM_IN_STRSET_EVAL_16(op, _x, y, ...)   _NM_IN_STRSET_streq (_x, y) op _NM_IN_STRSET_EVAL_15 (op, _x, __VA_ARGS__)
+
+#define _NM_IN_STRSET_EVAL_N2(op, _x, n, ...)   (_NM_IN_STRSET_EVAL_##n(op, _x, __VA_ARGS__))
+#define _NM_IN_STRSET_EVAL_N(op, x, n, ...)                       \
+    ({                                                            \
+        const char *_x = (x);                                     \
+        (   ((_x == NULL) && _NM_IN_SET_EVAL_N2    (op, (const char *) NULL, n, __VA_ARGS__)) \
+         || ((_x != NULL) && _NM_IN_STRSET_EVAL_N2 (op, _x,                  n, __VA_ARGS__)) \
+        ); \
+    })
+
+/* Beware that this does short-circuit evaluation (use "||" instead of "|")
+ * which has a possibly unexpected non-function-like behavior.
+ * Use NM_IN_STRSET_SE if you need all arguments to be evaluted. */
+#define NM_IN_STRSET(x, ...)               _NM_IN_STRSET_EVAL_N(||, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+/* "SE" stands for "side-effect". Contrary to NM_IN_STRSET(), this does not do
+ * short-circuit evaluation, which can make a difference if the arguments have
+ * side-effects. */
+#define NM_IN_STRSET_SE(x, ...)            _NM_IN_STRSET_EVAL_N(|, x, NM_NARG (__VA_ARGS__), __VA_ARGS__)
+
+#define NM_STRCHAR_ALL(str, ch_iter, predicate) \
+	({ \
+		gboolean _val = TRUE; \
+		const char *_str = (str); \
+		\
+		if (_str) { \
+			for (;;) { \
+				const char ch_iter = _str[0]; \
+				\
+				if (ch_iter != '\0') { \
+					if (predicate) {\
+						_str++; \
+						continue; \
+					} \
+					_val = FALSE; \
+				} \
+				break; \
+			} \
+		} \
+		_val; \
+	})
+
+#define NM_STRCHAR_ANY(str, ch_iter, predicate) \
+	({ \
+		gboolean _val = FALSE; \
+		const char *_str = (str); \
+		\
+		if (_str) { \
+			for (;;) { \
+				const char ch_iter = _str[0]; \
+				\
+				if (ch_iter != '\0') { \
+					if (predicate) { \
+						; \
+					} else { \
+						_str++; \
+						continue; \
+					} \
+					_val = TRUE; \
+				} \
+				break; \
+			} \
+		} \
+		_val; \
+	})
+
+/*****************************************************************************/
+
+#define nm_streq(s1, s2)  (strcmp (s1, s2) == 0)
+#define nm_streq0(s1, s2) (g_strcmp0 (s1, s2) == 0)
+
+/*****************************************************************************/
+
+static inline const char *
+nm_str_not_empty (const char *str)
+{
+	return str && str[0] ? str : NULL;
+}
+
+static inline char *
+nm_strdup_not_empty (const char *str)
+{
+	return str && str[0] ? g_strdup (str) : NULL;
+}
+
+static inline char *
+nm_str_realloc (char *str)
+{
+	gs_free char *s = str;
+
+	/* Returns a new clone of @str and frees @str. The point is that @str
+	 * possibly points to a larger chunck of memory. We want to freshly allocate
+	 * a buffer.
+	 *
+	 * We could use realloc(), but that might not do anything or leave
+	 * @str in its memory pool for chunks of a different size (bad for
+	 * fragmentation).
+	 *
+	 * This is only useful when we want to keep the buffer around for a long
+	 * time and want to re-allocate a more optimal buffer. */
+
+	return g_strdup (s);
+}
+
+/*****************************************************************************/
+
+#define NM_PRINT_FMT_QUOTED(cond, prefix, str, suffix, str_else) \
+	(cond) ? (prefix) : "", \
+	(cond) ? (str) : (str_else), \
+	(cond) ? (suffix) : ""
+#define NM_PRINT_FMT_QUOTE_STRING(arg) NM_PRINT_FMT_QUOTED((arg), "\"", (arg), "\"", "(null)")
+
+/*****************************************************************************/
+
+/* glib/C provides the following kind of assertions:
+ *   - assert() -- disable with NDEBUG
+ *   - g_return_if_fail() -- disable with G_DISABLE_CHECKS
+ *   - g_assert() -- disable with G_DISABLE_ASSERT
+ * but they are all enabled by default and usually even production builds have
+ * these kind of assertions enabled. It also means, that disabling assertions
+ * is an untested configuration, and might have bugs.
+ *
+ * Add our own assertion macro nm_assert(), which is disabled by default and must
+ * be explicitly enabled. They are useful for more expensive checks or checks that
+ * depend less on runtime conditions (that is, are generally expected to be true). */
+
+#ifndef NM_MORE_ASSERTS
+#define NM_MORE_ASSERTS 0
+#endif
+
+#if NM_MORE_ASSERTS
+#define nm_assert(cond) G_STMT_START { g_assert (cond); } G_STMT_END
+#define nm_assert_se(cond) G_STMT_START { if (G_LIKELY (cond)) { ; } else { g_assert (FALSE && (cond)); } } G_STMT_END
+#define nm_assert_not_reached() G_STMT_START { g_assert_not_reached (); } G_STMT_END
+#else
+#define nm_assert(cond) G_STMT_START { if (FALSE) { if (cond) { } } } G_STMT_END
+#define nm_assert_se(cond) G_STMT_START { if (G_LIKELY (cond)) { ; } } G_STMT_END
+#define nm_assert_not_reached() G_STMT_START { ; } G_STMT_END
+#endif
+
+/*****************************************************************************/
+
+#define NM_GOBJECT_PROPERTIES_DEFINE_BASE(...) \
+typedef enum { \
+	_PROPERTY_ENUMS_0, \
+	__VA_ARGS__ \
+	_PROPERTY_ENUMS_LAST, \
+} _PropertyEnums; \
+static GParamSpec *obj_properties[_PROPERTY_ENUMS_LAST] = { NULL, }
+
+#define NM_GOBJECT_PROPERTIES_DEFINE(obj_type, ...) \
+NM_GOBJECT_PROPERTIES_DEFINE_BASE (__VA_ARGS__); \
+static inline void \
+_notify (obj_type *obj, _PropertyEnums prop) \
+{ \
+	nm_assert (G_IS_OBJECT (obj)); \
+	nm_assert ((gsize) prop < G_N_ELEMENTS (obj_properties)); \
+	g_object_notify_by_pspec ((GObject *) obj, obj_properties[prop]); \
+}
+
+/*****************************************************************************/
+
+#define __NM_GET_PRIVATE(self, type, is_check, result_cmd) \
+	({ \
+		/* preserve the const-ness of self. Unfortunately, that
+		 * way, @self cannot be a void pointer */ \
+		typeof (self) _self = (self); \
+		\
+		/* Get compiler error if variable is of wrong type */ \
+		_nm_unused const type *_self2 = (_self); \
+		\
+		nm_assert (is_check (_self)); \
+		( result_cmd ); \
+	})
+
+#define _NM_GET_PRIVATE(self, type, is_check)     __NM_GET_PRIVATE(self, type, is_check, &_self->_priv)
+#define _NM_GET_PRIVATE_PTR(self, type, is_check) __NM_GET_PRIVATE(self, type, is_check,  _self->_priv)
+
+/*****************************************************************************/
+
+static inline gpointer
+nm_g_object_ref (gpointer obj)
+{
+	/* g_object_ref() doesn't accept NULL. */
+	if (obj)
+		g_object_ref (obj);
+	return obj;
+}
+
+static inline void
+nm_g_object_unref (gpointer obj)
+{
+	/* g_object_unref() doesn't accept NULL. Usully, we workaround that
+	 * by using g_clear_object(), but sometimes that is not convinient
+	 * (for example as as destroy function for a hash table that can contain
+	 * NULL values). */
+	if (obj)
+		g_object_unref (obj);
+}
+
+/* basically, replaces
+ *   g_clear_pointer (&location, g_free)
+ * with
+ *   nm_clear_g_free (&location)
+ *
+ * Another advantage is that by using a macro and typeof(), it is more
+ * typesafe and gives you for example a compiler warning when pp is a const
+ * pointer or points to a const-pointer.
+ */
+#define nm_clear_g_free(pp) \
+	({  \
+		typeof (*(pp)) *_pp = (pp); \
+		typeof (**_pp) *_p = *_pp; \
+		\
+		if (_p) { \
+			*_pp = NULL; \
+			g_free (_p); \
+		} \
+		!!_p; \
+	})
+
+static inline gboolean
+nm_clear_g_source (guint *id)
+{
+	if (id && *id) {
+		g_source_remove (*id);
+		*id = 0;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_signal_handler (gpointer self, gulong *id)
+{
+	if (id && *id) {
+		g_signal_handler_disconnect (self, *id);
+		*id = 0;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_variant (GVariant **variant)
+{
+	if (variant && *variant) {
+		g_variant_unref (*variant);
+		*variant = NULL;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static inline gboolean
+nm_clear_g_cancellable (GCancellable **cancellable)
+{
+	if (cancellable && *cancellable) {
+		g_cancellable_cancel (*cancellable);
+		g_object_unref (*cancellable);
+		*cancellable = NULL;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+/* Determine whether @x is a power of two (@x being an integer type).
+ * For the special cases @x equals zero or one, it also returns true.
+ * For negative @x, always returns FALSE. That only applies, if the data
+ * type of @x is signed. */
+#define nm_utils_is_power_of_two(x) ({ \
+		typeof(x) __x = (x); \
+		\
+		/* Check if the value is negative. In that case, return FALSE.
+		 * The first expression is a compile time constant, depending on whether
+		 * the type is signed. The second expression is a clumsy way for (__x >= 0),
+		 * which causes a compiler warning for unsigned types. */ \
+		    ( ( ((typeof(__x)) -1) > ((typeof(__x)) 0) ) || (__x > 0) || (__x == 0) ) \
+		 && ((__x & (__x - 1)) == 0); \
+	})
+
+/*****************************************************************************/
+
+/* check if @flags has exactly one flag (@check) set. You should call this
+ * only with @check being a compile time constant and a power of two. */
+#define NM_FLAGS_HAS(flags, check)  \
+    ( (G_STATIC_ASSERT_EXPR ( ((check) != 0) && ((check) & ((check)-1)) == 0 )), (NM_FLAGS_ANY ((flags), (check))) )
+
+#define NM_FLAGS_ANY(flags, check)  ( ( ((flags) & (check)) != 0       ) ? TRUE : FALSE )
+#define NM_FLAGS_ALL(flags, check)  ( ( ((flags) & (check)) == (check) ) ? TRUE : FALSE )
+
+#define NM_FLAGS_SET(flags, val)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		_flags | _val; \
+	})
+
+#define NM_FLAGS_UNSET(flags, val)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		_flags & (~_val); \
+	})
+
+#define NM_FLAGS_ASSIGN(flags, val, assign)  ({ \
+		const typeof(flags) _flags = (flags); \
+		const typeof(flags) _val = (val); \
+		\
+		(assign) \
+			? _flags | (_val) \
+			: _flags & (~_val); \
+	})
+
+/*****************************************************************************/
+
+#define _NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, ORIG_FUNC, VERSIONED_FUNC, ARGS_TYPED, ARGS) \
+RETURN_TYPE VERSIONED_FUNC ARGS_TYPED; \
+RETURN_TYPE VERSIONED_FUNC ARGS_TYPED \
+{ \
+    return ORIG_FUNC ARGS; \
+} \
+RETURN_TYPE ORIG_FUNC ARGS_TYPED; \
+__asm__(".symver "G_STRINGIFY(VERSIONED_FUNC)", "G_STRINGIFY(ORIG_FUNC)"@"G_STRINGIFY(VERSION))
+
+#define NM_BACKPORT_SYMBOL(VERSION, RETURN_TYPE, FUNC, ARGS_TYPED, ARGS) \
+_NM_BACKPORT_SYMBOL_IMPL(VERSION, RETURN_TYPE, FUNC, _##FUNC##_##VERSION, ARGS_TYPED, ARGS)
+
+/*****************************************************************************/
+
+#define nm_str_skip_leading_spaces(str) \
+	({ \
+		typeof (*(str)) *_str = (str); \
+		_nm_unused const char *_str_type_check = _str; \
+		\
+		if (_str) { \
+			while (g_ascii_isspace (_str[0])) \
+				_str++; \
+		} \
+		_str; \
+	})
+
+static inline char *
+nm_strstrip (char *str)
+{
+	/* g_strstrip doesn't like NULL. */
+	return str ? g_strstrip (str) : NULL;
+}
+
+/* g_ptr_array_sort()'s compare function takes pointers to the
+ * value. Thus, you cannot use strcmp directly. You can use
+ * nm_strcmp_p().
+ *
+ * Like strcmp(), this function is not forgiving to accept %NULL. */
+static inline int
+nm_strcmp_p (gconstpointer a, gconstpointer b)
+{
+	const char *s1 = *((const char **) a);
+	const char *s2 = *((const char **) b);
+
+	return strcmp (s1, s2);
+}
+
+/* like nm_strcmp_p(), suitable for g_ptr_array_sort_with_data().
+ * g_ptr_array_sort() just casts nm_strcmp_p() to a function of different
+ * signature. I guess, in glib there are knowledgeable people that ensure
+ * that this additional argument doesn't cause problems due to different ABI
+ * for every architecture that glib supports.
+ * For NetworkManager, we'd rather avoid such stunts.
+ **/
+static inline int
+nm_strcmp_p_with_data (gconstpointer a, gconstpointer b, gpointer user_data)
+{
+	const char *s1 = *((const char **) a);
+	const char *s2 = *((const char **) b);
+
+	return strcmp (s1, s2);
+}
+
+static inline int
+nm_cmp_uint32_p_with_data (gconstpointer p_a, gconstpointer p_b, gpointer user_data)
+{
+	const guint32 a = *((const guint32 *) p_a);
+	const guint32 b = *((const guint32 *) p_b);
+
+	if (a < b)
+		return -1;
+	if (a > b)
+		return 1;
+	return 0;
+}
+
+/*****************************************************************************/
+
+/* Taken from systemd's UNIQ_T and UNIQ macros. */
+
+#define NM_UNIQ_T(x, uniq) G_PASTE(__unique_prefix_, G_PASTE(x, uniq))
+#define NM_UNIQ __COUNTER__
+
+/*****************************************************************************/
+
+/* glib's MIN()/MAX() macros don't have function-like behavior, in that they evaluate
+ * the argument possibly twice.
+ *
+ * Taken from systemd's MIN()/MAX() macros. */
+
+#define NM_MIN(a, b) __NM_MIN(NM_UNIQ, a, NM_UNIQ, b)
+#define __NM_MIN(aq, a, bq, b) \
+	({ \
+		typeof (a) NM_UNIQ_T(A, aq) = (a); \
+		typeof (b) NM_UNIQ_T(B, bq) = (b); \
+		((NM_UNIQ_T(A, aq) < NM_UNIQ_T(B, bq)) ? NM_UNIQ_T(A, aq) : NM_UNIQ_T(B, bq)); \
+	})
+
+#define NM_MAX(a, b) __NM_MAX(NM_UNIQ, a, NM_UNIQ, b)
+#define __NM_MAX(aq, a, bq, b) \
+	({ \
+		typeof (a) NM_UNIQ_T(A, aq) = (a); \
+		typeof (b) NM_UNIQ_T(B, bq) = (b); \
+		((NM_UNIQ_T(A, aq) > NM_UNIQ_T(B, bq)) ? NM_UNIQ_T(A, aq) : NM_UNIQ_T(B, bq)); \
+	})
+
+#define NM_CLAMP(x, low, high) __NM_CLAMP(NM_UNIQ, x, NM_UNIQ, low, NM_UNIQ, high)
+#define __NM_CLAMP(xq, x, lowq, low, highq, high) \
+	({ \
+		typeof(x)NM_UNIQ_T(X,xq) = (x); \
+		typeof(low) NM_UNIQ_T(LOW,lowq) = (low); \
+		typeof(high) NM_UNIQ_T(HIGH,highq) = (high); \
+		\
+		( (NM_UNIQ_T(X,xq) > NM_UNIQ_T(HIGH,highq)) \
+		  ? NM_UNIQ_T(HIGH,highq) \
+		  : (NM_UNIQ_T(X,xq) < NM_UNIQ_T(LOW,lowq)) \
+		     ? NM_UNIQ_T(LOW,lowq) \
+		     : NM_UNIQ_T(X,xq)); \
+	})
+
+/*****************************************************************************/
+
+static inline guint
+nm_encode_version (guint major, guint minor, guint micro) {
+	/* analog to the preprocessor macro NM_ENCODE_VERSION(). */
+	return (major << 16) | (minor << 8) | micro;
+}
+
+static inline void
+nm_decode_version (guint version, guint *major, guint *minor, guint *micro) {
+	*major = (version & 0xFFFF0000u) >> 16;
+	*minor = (version & 0x0000FF00u) >>  8;
+	*micro = (version & 0x000000FFu);
+}
+
+/*****************************************************************************/
+
+/* taken from systemd's DECIMAL_STR_MAX()
+ *
+ * Returns the number of chars needed to format variables of the
+ * specified type as a decimal string. Adds in extra space for a
+ * negative '-' prefix (hence works correctly on signed
+ * types). Includes space for the trailing NUL. */
+#define NM_DECIMAL_STR_MAX(type) \
+    (2+(sizeof(type) <= 1 ? 3 : \
+        sizeof(type) <= 2 ? 5 : \
+        sizeof(type) <= 4 ? 10 : \
+        sizeof(type) <= 8 ? 20 : sizeof(int[-2*(sizeof(type) > 8)])))
+
+/*****************************************************************************/
+
+/* if @str is NULL, return "(null)". Otherwise, allocate a buffer using
+ * alloca() of size @bufsize and fill it with @str. @str will be quoted with
+ * single quote, and in case @str is too long, the final quote will be '^'. */
+#define nm_strquote_a(bufsize, str) \
+	({ \
+		G_STATIC_ASSERT ((bufsize) >= 6); \
+		const gsize _BUFSIZE = (bufsize); \
+		const char *const _s = (str); \
+		char *_r; \
+		gsize _l; \
+		gboolean _truncated; \
+		\
+		nm_assert (_BUFSIZE >= 6); \
+		\
+		if (_s) { \
+			_l = strlen (_s) + 3; \
+			if ((_truncated = (_BUFSIZE < _l))) \
+				_l = _BUFSIZE; \
+			\
+			_r = g_alloca (_l); \
+			_r[0] = '\''; \
+			memcpy (&_r[1], _s, _l - 3); \
+			_r[_l - 2] = _truncated ? '^' : '\''; \
+			_r[_l - 1] = '\0'; \
+		} else \
+			_r = "(null)"; \
+		_r; \
+	})
+
+#define nm_sprintf_buf(buf, format, ...) ({ \
+		char * _buf = (buf); \
+		int _buf_len; \
+		\
+		/* some static assert trying to ensure that the buffer is statically allocated.
+		 * It disallows a buffer size of sizeof(gpointer) to catch that. */ \
+		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) != sizeof (char *)); \
+		_buf_len = g_snprintf (_buf, sizeof (buf), \
+		                       ""format"", ##__VA_ARGS__); \
+		nm_assert (_buf_len < sizeof (buf)); \
+		_buf; \
+	})
+
+#define nm_sprintf_bufa(n_elements, format, ...) \
+	({ \
+		char *_buf; \
+		int _buf_len; \
+		\
+		G_STATIC_ASSERT (sizeof (char[MAX ((n_elements), 1)]) == (n_elements)); \
+		_buf = g_alloca (n_elements); \
+		_buf_len = g_snprintf (_buf, (n_elements), \
+		                       ""format"", ##__VA_ARGS__); \
+		nm_assert (_buf_len < (n_elements)); \
+		_buf; \
+	})
+
+/*****************************************************************************/
+
+/**
+ * The boolean type _Bool is C99 while we mostly stick to C89. However, _Bool is too
+ * convinient to miss and is effectively available in gcc and clang. So, just use it.
+ *
+ * Usually, one would include "stdbool.h" to get the "bool" define which aliases
+ * _Bool. We provide this define here, because we want to make use of it anywhere.
+ * (also, stdbool.h is again C99).
+ *
+ * Using _Bool has advantages over gboolean:
+ *
+ * - commonly _Bool is one byte large, instead of gboolean's 4 bytes (because gboolean
+ *   is a typedef for gint). Especially when having boolean fields in a struct, we can
+ *   thereby easily save some space.
+ *
+ * - _Bool type guarantees that two "true" expressions compare equal. E.g. the follwing
+ *   will not work:
+ *        gboolean v1 = 1;
+ *        gboolean v2 = 2;
+ *        g_assert_cmpint (v1, ==, v2); // will fail
+ *   For that, we often to use !! to coerce gboolean values to 0 or 1:
+ *        g_assert_cmpint (!!v2, ==, TRUE);
+ *   With _Bool type, this will be handled properly by the compiler.
+ *
+ * - For structs, we might want to safe even more space and use bitfields:
+ *       struct s1 {
+ *           gboolean v1:1;
+ *       };
+ *   But the problem here is that gboolean is signed, so that
+ *   v1 will be either 0 or -1 (not 1, TRUE). Thus, the following
+ *   fails:
+ *      struct s1 s = { .v1 = TRUE, };
+ *      g_assert_cmpint (s1.v1, ==, TRUE);
+ *   It will however work just fine with bool/_Bool while retaining the
+ *   notion of having a boolean value.
+ *
+ * Also, add the defines for "true" and "false". Those are nicely highlighted by the editor
+ * as special types, contrary to glib's "TRUE"/"FALSE".
+ */
+
+#ifndef bool
+#define bool _Bool
+#define true    1
+#define false   0
+#endif
+
+
+#ifdef _G_BOOLEAN_EXPR
+/* g_assert() uses G_LIKELY(), which in turn uses _G_BOOLEAN_EXPR().
+ * As glib's implementation uses a local variable _g_boolean_var_,
+ * we cannot do
+ *   g_assert (some_macro ());
+ * where some_macro() itself expands to ({g_assert(); ...}).
+ * In other words, you cannot have a g_assert() inside a g_assert()
+ * without getting a -Werror=shadow failure.
+ *
+ * Workaround that by re-defining _G_BOOLEAN_EXPR()
+ **/
+#undef  _G_BOOLEAN_EXPR
+#define __NM_G_BOOLEAN_EXPR_IMPL(v, expr) \
+	({ \
+		int NM_UNIQ_T(V, v); \
+		\
+		if (expr) \
+			NM_UNIQ_T(V, v) = 1; \
+		else \
+			NM_UNIQ_T(V, v) = 0; \
+		NM_UNIQ_T(V, v); \
+	})
+#define _G_BOOLEAN_EXPR(expr) __NM_G_BOOLEAN_EXPR_IMPL (NM_UNIQ, expr)
+#endif
+
+
+/*****************************************************************************/
+
+#endif /* __NM_MACROS_INTERNAL_H__ */
diff --git a/shared/nm-utils/nm-shared-utils.c b/shared/nm-utils/nm-shared-utils.c
new file mode 100644
index 0000000..38bb818
--- /dev/null
+++ b/shared/nm-utils/nm-shared-utils.c
@@ -0,0 +1,318 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2016 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nm-shared-utils.h"
+
+#include <errno.h>
+
+/*****************************************************************************/
+
+void
+nm_utils_strbuf_append_c (char **buf, gsize *len, char c)
+{
+	switch (*len) {
+	case 0:
+		return;
+	case 1:
+		(*buf)[0] = '\0';
+		*len = 0;
+		(*buf)++;
+		return;
+	default:
+		(*buf)[0] = c;
+		(*buf)[1] = '\0';
+		(*len)--;
+		(*buf)++;
+		return;
+	}
+}
+
+void
+nm_utils_strbuf_append_str (char **buf, gsize *len, const char *str)
+{
+	gsize src_len;
+
+	switch (*len) {
+	case 0:
+		return;
+	case 1:
+		if (!str || !*str) {
+			(*buf)[0] = '\0';
+			return;
+		}
+		(*buf)[0] = '\0';
+		*len = 0;
+		(*buf)++;
+		return;
+	default:
+		if (!str || !*str) {
+			(*buf)[0] = '\0';
+			return;
+		}
+		src_len = g_strlcpy (*buf, str, *len);
+		if (src_len >= *len) {
+			*buf = &(*buf)[*len];
+			*len = 0;
+		} else {
+			*buf = &(*buf)[src_len];
+			*len -= src_len;
+		}
+		return;
+	}
+}
+
+void
+nm_utils_strbuf_append (char **buf, gsize *len, const char *format, ...)
+{
+	char *p = *buf;
+	va_list args;
+	gint retval;
+
+	if (*len == 0)
+		return;
+
+	va_start (args, format);
+	retval = g_vsnprintf (p, *len, format, args);
+	va_end (args);
+
+	if (retval >= *len) {
+		*buf = &p[*len];
+		*len = 0;
+	} else {
+		*buf = &p[retval];
+		*len -= retval;
+	}
+}
+
+/*****************************************************************************/
+
+/* _nm_utils_ascii_str_to_int64:
+ *
+ * A wrapper for g_ascii_strtoll, that checks whether the whole string
+ * can be successfully converted to a number and is within a given
+ * range. On any error, @fallback will be returned and %errno will be set
+ * to a non-zero value. On success, %errno will be set to zero, check %errno
+ * for errors. Any trailing or leading (ascii) white space is ignored and the
+ * functions is locale independent.
+ *
+ * The function is guaranteed to return a value between @min and @max
+ * (inclusive) or @fallback. Also, the parsing is rather strict, it does
+ * not allow for any unrecognized characters, except leading and trailing
+ * white space.
+ **/
+gint64
+_nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback)
+{
+	gint64 v;
+	const char *s = NULL;
+
+	if (str) {
+		while (g_ascii_isspace (str[0]))
+			str++;
+	}
+	if (!str || !str[0]) {
+		errno = EINVAL;
+		return fallback;
+	}
+
+	errno = 0;
+	v = g_ascii_strtoll (str, (char **) &s, base);
+
+	if (errno != 0)
+		return fallback;
+	if (s[0] != '\0') {
+		while (g_ascii_isspace (s[0]))
+			s++;
+		if (s[0] != '\0') {
+			errno = EINVAL;
+			return fallback;
+		}
+	}
+	if (v > max || v < min) {
+		errno = ERANGE;
+		return fallback;
+	}
+
+	return v;
+}
+
+/*****************************************************************************/
+
+gint
+_nm_utils_ascii_str_to_bool (const char *str,
+                             gint default_value)
+{
+	gsize len;
+	char *s = NULL;
+
+	if (!str)
+		return default_value;
+
+	while (str[0] && g_ascii_isspace (str[0]))
+		str++;
+
+	if (!str[0])
+		return default_value;
+
+	len = strlen (str);
+	if (g_ascii_isspace (str[len - 1])) {
+		s = g_strdup (str);
+		g_strchomp (s);
+		str = s;
+	}
+
+	if (!g_ascii_strcasecmp (str, "true") || !g_ascii_strcasecmp (str, "yes") || !g_ascii_strcasecmp (str, "on") || !g_ascii_strcasecmp (str, "1"))
+		default_value = TRUE;
+	else if (!g_ascii_strcasecmp (str, "false") || !g_ascii_strcasecmp (str, "no") || !g_ascii_strcasecmp (str, "off") || !g_ascii_strcasecmp (str, "0"))
+		default_value = FALSE;
+	if (s)
+		g_free (s);
+	return default_value;
+}
+
+/*****************************************************************************/
+
+G_DEFINE_QUARK (nm-utils-error-quark, nm_utils_error)
+
+void
+nm_utils_error_set_cancelled (GError **error,
+                              gboolean is_disposing,
+                              const char *instance_name)
+{
+	if (is_disposing) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING,
+		             "Disposing %s instance",
+		             instance_name && *instance_name ? instance_name : "source");
+	} else {
+		g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_CANCELLED,
+		                     "Request cancelled");
+	}
+}
+
+gboolean
+nm_utils_error_is_cancelled (GError *error,
+                             gboolean consider_is_disposing)
+{
+	if (error) {
+		if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+			return TRUE;
+		if (   consider_is_disposing
+		    && g_error_matches (error, NM_UTILS_ERROR, NM_UTILS_ERROR_CANCELLED_DISPOSING))
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+/**
+ * nm_g_object_set_property:
+ * @object: the target object
+ * @property_name: the property name
+ * @value: the #GValue to set
+ * @error: (allow-none): optional error argument
+ *
+ * A reimplementation of g_object_set_property(), but instead
+ * returning an error instead of logging a warning. All g_object_set*()
+ * versions in glib require you to not pass invalid types or they will
+ * log a g_warning() -- without reporting an error. We don't want that,
+ * so we need to hack error checking around it.
+ *
+ * Returns: whether the value was successfully set.
+ */
+gboolean
+nm_g_object_set_property (GObject *object,
+                          const gchar  *property_name,
+                          const GValue *value,
+                          GError **error)
+{
+	GParamSpec *pspec;
+	nm_auto_unset_gvalue GValue tmp_value = G_VALUE_INIT;
+	GObjectClass *klass;
+
+	g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
+	g_return_val_if_fail (property_name != NULL, FALSE);
+	g_return_val_if_fail (G_IS_VALUE (value), FALSE);
+	g_return_val_if_fail (!error || !*error, FALSE);
+
+	/* g_object_class_find_property() does g_param_spec_get_redirect_target(),
+	 * where we differ from a plain g_object_set_property(). */
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (object), property_name);
+
+	if (!pspec) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("object class '%s' has no property named '%s'"),
+		             G_OBJECT_TYPE_NAME (object),
+		             property_name);
+		return FALSE;
+	}
+	if (!(pspec->flags & G_PARAM_WRITABLE)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("property '%s' of object class '%s' is not writable"),
+		             pspec->name,
+		             G_OBJECT_TYPE_NAME (object));
+		return FALSE;
+	}
+	if ((pspec->flags & G_PARAM_CONSTRUCT_ONLY)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("construct property \"%s\" for object '%s' can't be set after construction"),
+		             pspec->name, G_OBJECT_TYPE_NAME (object));
+		return FALSE;
+	}
+
+	klass = g_type_class_peek (pspec->owner_type);
+	if (klass == NULL) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("'%s::%s' is not a valid property name; '%s' is not a GObject subtype"),
+		            g_type_name (pspec->owner_type), pspec->name, g_type_name (pspec->owner_type));
+		return FALSE;
+	}
+
+	/* provide a copy to work from, convert (if necessary) and validate */
+	g_value_init (&tmp_value, pspec->value_type);
+	if (!g_value_transform (value, &tmp_value)) {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("unable to set property '%s' of type '%s' from value of type '%s'"),
+		             pspec->name,
+		             g_type_name (pspec->value_type),
+		             G_VALUE_TYPE_NAME (value));
+		return FALSE;
+	}
+	if (   g_param_value_validate (pspec, &tmp_value)
+	    && !(pspec->flags & G_PARAM_LAX_VALIDATION)) {
+		gs_free char *contents = g_strdup_value_contents (value);
+
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_UNKNOWN,
+		             _("value \"%s\" of type '%s' is invalid or out of range for property '%s' of type '%s'"),
+		             contents,
+		             G_VALUE_TYPE_NAME (value),
+		             pspec->name,
+		             g_type_name (pspec->value_type));
+		return FALSE;
+	}
+
+	g_object_set_property (object, property_name, &tmp_value);
+	return TRUE;
+}
+
+/*****************************************************************************/
diff --git a/shared/nm-utils/nm-shared-utils.h b/shared/nm-utils/nm-shared-utils.h
new file mode 100644
index 0000000..5d8a3a8
--- /dev/null
+++ b/shared/nm-utils/nm-shared-utils.h
@@ -0,0 +1,85 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2016 Red Hat, Inc.
+ */
+
+#ifndef __NM_SHARED_UTILS_H__
+#define __NM_SHARED_UTILS_H__
+
+/*****************************************************************************/
+
+static inline void
+_nm_utils_strbuf_init (char *buf, gsize len, char **p_buf_ptr, gsize *p_buf_len)
+{
+	NM_SET_OUT (p_buf_len, len);
+	NM_SET_OUT (p_buf_ptr, buf);
+	buf[0] = '\0';
+}
+
+#define nm_utils_strbuf_init(buf, p_buf_ptr, p_buf_len) \
+	G_STMT_START { \
+		G_STATIC_ASSERT (G_N_ELEMENTS (buf) == sizeof (buf) && sizeof (buf) > sizeof (char *)); \
+		_nm_utils_strbuf_init ((buf), sizeof (buf), (p_buf_ptr), (p_buf_len)); \
+	} G_STMT_END
+void nm_utils_strbuf_append (char **buf, gsize *len, const char *format, ...) _nm_printf (3, 4);
+void nm_utils_strbuf_append_c (char **buf, gsize *len, char c);
+void nm_utils_strbuf_append_str (char **buf, gsize *len, const char *str);
+
+/*****************************************************************************/
+
+gint64 _nm_utils_ascii_str_to_int64 (const char *str, guint base, gint64 min, gint64 max, gint64 fallback);
+
+gint _nm_utils_ascii_str_to_bool (const char *str,
+                                  gint default_value);
+
+/*****************************************************************************/
+
+/**
+ * NMUtilsError:
+ * @NM_UTILS_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_UTILS_ERROR_CANCELLED_DISPOSING: when disposing an object that has
+ *   pending aynchronous operations, the operation is cancelled with this
+ *   error reason. Depending on the usage, this might indicate a bug because
+ *   usually the target object should stay alive as long as there are pending
+ *   operations.
+ */
+typedef enum {
+	NM_UTILS_ERROR_UNKNOWN = 0,                 /*< nick=Unknown >*/
+	NM_UTILS_ERROR_CANCELLED_DISPOSING,         /*< nick=CancelledDisposing >*/
+} NMUtilsError;
+
+#define NM_UTILS_ERROR (nm_utils_error_quark ())
+GQuark nm_utils_error_quark (void);
+
+void nm_utils_error_set_cancelled (GError **error,
+                                   gboolean is_disposing,
+                                   const char *instance_name);
+gboolean nm_utils_error_is_cancelled (GError *error,
+                                      gboolean consider_is_disposing);
+
+/*****************************************************************************/
+
+gboolean nm_g_object_set_property (GObject *object,
+                                   const gchar  *property_name,
+                                   const GValue *value,
+                                   GError **error);
+
+/*****************************************************************************/
+
+#endif /* __NM_SHARED_UTILS_H__ */
diff --git a/shared/nm-utils/nm-test-utils.h b/shared/nm-utils/nm-test-utils.h
new file mode 100644
index 0000000..7be7e25
--- /dev/null
+++ b/shared/nm-utils/nm-test-utils.h
@@ -0,0 +1,1838 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef __NM_TEST_UTILS_H__
+#define __NM_TEST_UTILS_H__
+
+/*******************************************************************************
+ * HOWTO run tests.
+ *
+ * Our tests (make check) include this header-only file nm-test-utils.h.
+ *
+ * Logging:
+ *   In tests, nm-logging redirects to glib logging. By default, glib suppresses all debug
+ *   messages unless you set G_MESSAGES_DEBUG. To enable debug logging, you can explicitly set
+ *   G_MESSAGES_DEBUG. Otherwise, nm-test will set G_MESSAGES_DEBUG=all in debug mode (see below).
+ *   For nm-logging, you can configure the log-level and domains via NMTST_DEBUG environment
+ *   variable.
+ *
+ * Assert-logging:
+ *   Some tests assert against logged messages (g_test_expect_message()).
+ *   By specifying no-expect-message in NMTST_DEBUG, you can disable assert logging
+ *   and g_test_assert_expected_messages() will not fail.
+ *
+ * NMTST_SEED_RAND environment variable:
+ *   Tests that use random numbers from nmtst_get_rand() get seeded randomly at each start.
+ *   You can specify the seed by setting NMTST_SEED_RAND. Also, tests will print the seed
+ *   to stdout, so that you know the choosen seed.
+ *
+ *
+ * NMTST_DEBUG environment variable:
+ *
+ * "debug", "no-debug": when at test is run in debug mode, it might behave differently,
+ *   depending on the test. See nmtst_is_debug().
+ *   Known differences:
+ *    - a test might leave the logging level unspecified. In this case, running in
+ *      debug mode, will turn on DEBUG logging, otherwise WARN logging only.
+ *    - if G_MESSAGES_DEBUG is unset, nm-test will set G_MESSAGES_DEBUG=all
+ *      for tests that don't do assert-logging.
+ *   Debug mode is determined as follows (highest priority first):
+ *    - command line option --debug/--no-debug
+ *    - NMTST_DEBUG=debug/no-debug
+ *    - setting NMTST_DEBUG implies debugging turned on
+ *    - g_test_verbose()
+ *
+ * "no-expect-message": for tests that would assert against log messages, disable
+ *   those asserts.
+ *
+ * "log-level=LEVEL", "log-domains=DOMAIN": reset the log level and domain for tests.
+ *    It only has an effect for nm-logging messages.
+ *    This has no effect if the test asserts against logging (unless no-expect-message),
+ *    otherwise, changing the logging would break tests.
+ *    If you set the level to DEBUG or TRACE, it also sets G_MESSAGES_DEBUG=all (unless
+ *    in assert-logging mode and unless G_MESSAGES_DEBUG is already defined).
+ *
+ * "TRACE", this is shorthand for "log-level=TRACE".
+ *
+ * "D", this is shorthand for "log-level=TRACE,no-expect-message".
+ *
+ * "sudo-cmd=PATH": when running root tests as normal user, the test will execute
+ *   itself by invoking sudo at PATH.
+ *   For example
+ *     NMTST_DEBUG="sudo-cmd=$PWD/tools/test-sudo-wrapper.sh" make -C src/platform/tests/ check
+ *
+ * "slow|quick|thorough": enable/disable long-running tests. This sets nmtst_test_quick().
+ *   Whether long-running tests are enabled is determined as follows (highest priority first):
+ *     - specifying the value in NMTST_DEBUG has highest priority
+ *     - respect g_test_quick(), if the command line contains '-mslow', '-mquick', '-mthorough'.
+ *     - use compile time default
+ *
+ * "p=PATH"|"s=PATH": passes the path to g_test_init() as "-p" and "-s", respectively.
+ *   Unfortunately, these options conflict with "--tap" which our makefile passes to the
+ *   tests, thus it's only useful outside of `make check`.
+ *
+ *******************************************************************************/
+
+#include "nm-default.h"
+
+#if defined(NM_ASSERT_NO_MSG) && NM_ASSERT_NO_MSG
+#undef g_return_if_fail_warning
+#undef g_assertion_message_expr
+#endif
+
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include "nm-utils.h"
+
+/*****************************************************************************/
+
+#define NMTST_G_RETURN_MSG_S(expr) "*: assertion '"NM_ASSERT_G_RETURN_EXPR(expr)"' failed"
+#define NMTST_G_RETURN_MSG(expr)   NMTST_G_RETURN_MSG_S(#expr)
+
+/*****************************************************************************/
+
+/* general purpose functions that have no dependency on other nmtst functions */
+
+#define nmtst_assert_error(error, expect_error_domain, expect_error_code, expect_error_pattern) \
+	G_STMT_START { \
+		GError *_error = (error); \
+		GQuark _expect_error_domain = (expect_error_domain); \
+		const char *_expect_error_pattern = (expect_error_pattern); \
+		\
+		if (_expect_error_domain) \
+			g_assert_error (_error, _expect_error_domain, (expect_error_code)); \
+		else \
+			g_assert (_error); \
+		g_assert (_error->message); \
+		if (   _expect_error_pattern \
+		    && !g_pattern_match_simple (_expect_error_pattern, _error->message)) { \
+			g_error ("%s:%d: error message does not have expected pattern '%s'. Instead it is '%s' (%s, %d)", \
+			         __FILE__, __LINE__, \
+			         _expect_error_pattern, _error->message, g_quark_to_string (_error->domain), _error->code); \
+		} \
+	} G_STMT_END
+
+#define NMTST_WAIT(max_wait_ms, wait) \
+	({ \
+		gboolean _not_expired = TRUE; \
+		gint64 _nmtst_end, _nmtst_max_wait_us = (max_wait_ms) * 1000L; \
+		\
+		_nmtst_end = g_get_monotonic_time () + _nmtst_max_wait_us; \
+		while (TRUE) { \
+			{ wait }; \
+			if (g_get_monotonic_time () > _nmtst_end) { \
+				_not_expired = FALSE; \
+				break; \
+			} \
+		} \
+		_not_expired; \
+	})
+
+#define NMTST_WAIT_ASSERT(max_wait_ms, wait) \
+	G_STMT_START { \
+		if (!(NMTST_WAIT (max_wait_ms, wait))) \
+			g_assert_not_reached (); \
+	} G_STMT_END
+
+#define nmtst_assert_success(success, error) \
+	G_STMT_START { \
+		g_assert_no_error (error); \
+		g_assert ((success)); \
+	} G_STMT_END
+
+#define nmtst_assert_no_success(success, error) \
+	G_STMT_START { \
+		g_assert (error); \
+		g_assert (!(success)); \
+	} G_STMT_END
+
+/*****************************************************************************/
+
+struct __nmtst_internal
+{
+	GRand *rand0;
+	guint32 rand_seed;
+	GRand *rand;
+	gboolean is_debug;
+	gboolean assert_logging;
+	gboolean no_expect_message;
+	gboolean test_quick;
+	gboolean test_tap_log;
+	char *sudo_cmd;
+	char **orig_argv;
+};
+
+extern struct __nmtst_internal __nmtst_internal;
+
+#define NMTST_DEFINE() \
+struct __nmtst_internal __nmtst_internal = { 0 }; \
+\
+__attribute__ ((destructor)) static void \
+_nmtst_exit (void) \
+{ \
+	__nmtst_internal.assert_logging = FALSE; \
+	g_test_assert_expected_messages (); \
+	nmtst_free (); \
+}
+
+
+inline static gboolean
+nmtst_initialized (void)
+{
+	return !!__nmtst_internal.rand0;
+}
+
+#define __NMTST_LOG(cmd, ...) \
+	G_STMT_START { \
+		g_assert (nmtst_initialized ()); \
+		if (!__nmtst_internal.assert_logging || __nmtst_internal.no_expect_message) { \
+			cmd (__VA_ARGS__); \
+		} else { \
+			printf (_NM_UTILS_MACRO_FIRST (__VA_ARGS__) "\n" _NM_UTILS_MACRO_REST (__VA_ARGS__)); \
+		} \
+	} G_STMT_END
+
+/* split the string inplace at specific delimiters, allowing escaping with '\\'.
+ * Returns a zero terminated array of pointers into @str.
+ *
+ * The caller must g_free() the returned argv array.
+ **/
+inline static char **
+nmtst_str_split (char *str, const char *delimiters)
+{
+	const char *d;
+	GArray *result = g_array_sized_new (TRUE, FALSE, sizeof (char *), 3);
+
+	g_assert (str);
+	g_assert (delimiters && !strchr (delimiters, '\\'));
+
+	while (*str) {
+		gsize i = 0, j = 0;
+
+		while (TRUE) {
+			char c = str[i];
+
+			if (c == '\0') {
+				str[j++] = 0;
+				break;
+			} else if (c == '\\') {
+				str[j++] = str[++i];
+				if (!str[i])
+					break;
+			} else {
+				for (d = delimiters; *d; d++) {
+					if (c == *d) {
+						str[j++] = 0;
+						i++;
+						goto BREAK_INNER_LOOPS;
+					}
+				}
+				str[j++] = c;
+			}
+			i++;
+		}
+
+BREAK_INNER_LOOPS:
+		g_array_append_val (result, str);
+		str = &str[i];
+	}
+
+	return (char **) g_array_free (result, FALSE);
+}
+
+
+/* free instances allocated by nmtst (especially nmtst_init()) on shutdown
+ * to release memory. After nmtst_free(), the test is uninitialized again. */
+inline static void
+nmtst_free (void)
+{
+	if (!nmtst_initialized ())
+		return;
+
+	g_rand_free (__nmtst_internal.rand0);
+	if (__nmtst_internal.rand)
+		g_rand_free (__nmtst_internal.rand);
+	g_free (__nmtst_internal.sudo_cmd);
+	g_strfreev (__nmtst_internal.orig_argv);
+
+	memset (&__nmtst_internal, 0, sizeof (__nmtst_internal));
+}
+
+inline static void
+__nmtst_init (int *argc, char ***argv, gboolean assert_logging, const char *log_level, const char *log_domains, gboolean *out_set_logging)
+{
+	const char *nmtst_debug;
+	gboolean is_debug = FALSE;
+	char *c_log_level = NULL, *c_log_domains = NULL;
+	char *sudo_cmd = NULL;
+	GArray *debug_messages = g_array_new (TRUE, FALSE, sizeof (char *));
+	int i;
+	gboolean no_expect_message = FALSE;
+	gboolean _out_set_logging;
+	gboolean test_quick = FALSE;
+	gboolean test_quick_set = FALSE;
+	gboolean test_quick_argv = FALSE;
+	gs_unref_ptrarray GPtrArray *p_tests = NULL;
+	gs_unref_ptrarray GPtrArray *s_tests = NULL;
+
+	if (!out_set_logging)
+		out_set_logging = &_out_set_logging;
+	*out_set_logging = FALSE;
+
+	g_assert (!nmtst_initialized ());
+
+	g_assert (!((!!argc) ^ (!!argv)));
+	g_assert (!argc || (g_strv_length (*argv) == *argc));
+	g_assert (!assert_logging || (!log_level && !log_domains));
+
+#ifdef __NETWORKMANAGER_UTILS_H__
+	if (!nm_utils_get_testing_initialized ())
+		_nm_utils_set_testing (_NM_UTILS_TEST_GENERAL);
+#endif
+
+	if (argc)
+		__nmtst_internal.orig_argv = g_strdupv (*argv);
+
+	__nmtst_internal.assert_logging = !!assert_logging;
+
+	nm_g_type_init ();
+
+	is_debug = g_test_verbose ();
+
+	nmtst_debug = g_getenv ("NMTST_DEBUG");
+	if (nmtst_debug) {
+		char **d_argv, **i_argv, *nmtst_debug_copy;
+
+		/* By setting then NMTST_DEBUG variable, @is_debug is set automatically.
+		 * This can be reverted with no-debug (on command line or environment variable). */
+		is_debug = TRUE;
+
+		nmtst_debug_copy = g_strdup (nmtst_debug);
+		d_argv = nmtst_str_split (nmtst_debug_copy, ",; \t\r\n");
+
+		for (i_argv = d_argv; *i_argv; i_argv++) {
+			const char *debug = *i_argv;
+
+			if (!g_ascii_strcasecmp (debug, "debug"))
+				is_debug = TRUE;
+			else if (!g_ascii_strcasecmp (debug, "no-debug")) {
+				/* when specifying the NMTST_DEBUG variable, we set is_debug to true. Use this flag to disable this
+				 * (e.g. for only setting the log-level, but not is_debug). */
+				is_debug = FALSE;
+			} else if (!g_ascii_strncasecmp (debug, "log-level=", strlen ("log-level="))) {
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup (&debug[strlen ("log-level=")]);
+			} else if (!g_ascii_strcasecmp (debug, "D")) {
+				/* shorthand for "log-level=TRACE,no-expect-message" */
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup ("TRACE");
+				no_expect_message = TRUE;
+			} else if (!g_ascii_strcasecmp (debug, "TRACE")) {
+				g_free (c_log_level);
+				log_level = c_log_level = g_strdup ("TRACE");
+			} else if (!g_ascii_strncasecmp (debug, "log-domains=", strlen ("log-domains="))) {
+				g_free (c_log_domains);
+				log_domains = c_log_domains = g_strdup (&debug[strlen ("log-domains=")]);
+			} else if (!g_ascii_strncasecmp (debug, "sudo-cmd=", strlen ("sudo-cmd="))) {
+				g_free (sudo_cmd);
+				sudo_cmd = g_strdup (&debug[strlen ("sudo-cmd=")]);
+			} else if (!g_ascii_strcasecmp (debug, "no-expect-message")) {
+				no_expect_message = TRUE;
+			} else if (!g_ascii_strncasecmp (debug, "p=", strlen ("p="))) {
+				if (!p_tests)
+					p_tests = g_ptr_array_new_with_free_func (g_free);
+				g_ptr_array_add (p_tests, g_strdup (&debug[strlen ("p=")]));
+			} else if (!g_ascii_strncasecmp (debug, "s=", strlen ("s="))) {
+				if (!s_tests)
+					s_tests = g_ptr_array_new_with_free_func (g_free);
+				g_ptr_array_add (s_tests, g_strdup (&debug[strlen ("s=")]));
+			} else if (!g_ascii_strcasecmp (debug, "slow") || !g_ascii_strcasecmp (debug, "thorough")) {
+				test_quick = FALSE;
+				test_quick_set = TRUE;
+			} else if (!g_ascii_strcasecmp (debug, "quick")) {
+				test_quick = TRUE;
+				test_quick_set = TRUE;
+			} else {
+				char *msg = g_strdup_printf (">>> nmtst: ignore unrecognized NMTST_DEBUG option \"%s\"", debug);
+
+				g_array_append_val (debug_messages, msg);
+			}
+		}
+
+		g_free (d_argv);
+		g_free (nmtst_debug_copy);
+	}
+
+	if (__nmtst_internal.orig_argv) {
+		char **a = __nmtst_internal.orig_argv;
+
+		for (; *a; a++) {
+			if (!g_ascii_strcasecmp (*a, "--debug"))
+				is_debug = TRUE;
+			else if (!g_ascii_strcasecmp (*a, "--no-debug"))
+				is_debug = FALSE;
+			else if (   !strcmp (*a, "-m=slow")
+			         || !strcmp (*a, "-m=thorough")
+			         || !strcmp (*a, "-m=quick")
+			         || (!strcmp (*a, "-m") && *(a+1)
+			                                && (   !strcmp (*(a+1), "quick")
+			                                    || !strcmp (*(a+1), "slow")
+			                                    || !strcmp (*(a+1), "thorough"))))
+				test_quick_argv = TRUE;
+			else if (strcmp (*a, "--tap") == 0)
+				__nmtst_internal.test_tap_log = TRUE;
+		}
+	}
+
+	if (!argc || g_test_initialized ()) {
+		if (p_tests || s_tests) {
+			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for test which calls g_test_init() itself");
+
+			g_array_append_val (debug_messages, msg);
+		}
+	} else {
+		/* g_test_init() is a variadic function, so we cannot pass it
+		 * (variadic) arguments. If you need to pass additional parameters,
+		 * call nmtst_init() with argc==NULL and call g_test_init() yourself. */
+
+		/* g_test_init() sets g_log_set_always_fatal() for G_LOG_LEVEL_WARNING
+		 * and G_LOG_LEVEL_CRITICAL. So, beware that the test will fail if you
+		 * have any WARN or ERR log messages -- unless you g_test_expect_message(). */
+		GPtrArray *arg_array = g_ptr_array_new ();
+		gs_free char **arg_array_c = NULL;
+		int arg_array_n, j;
+		static char **s_tests_x, **p_tests_x;
+
+		if (*argc) {
+			for (i = 0; i < *argc; i++)
+				g_ptr_array_add (arg_array, (*argv)[i]);
+		} else
+			g_ptr_array_add (arg_array, "./test");
+
+		if (test_quick_set && !test_quick_argv)
+			g_ptr_array_add (arg_array, "-m=quick");
+
+		if (!__nmtst_internal.test_tap_log) {
+			for (i = 0; p_tests && i < p_tests->len; i++) {
+				g_ptr_array_add (arg_array, "-p");
+				g_ptr_array_add (arg_array, p_tests->pdata[i]);
+			}
+			for (i = 0; s_tests && i < s_tests->len; i++) {
+				g_ptr_array_add (arg_array, "-s");
+				g_ptr_array_add (arg_array, s_tests->pdata[i]);
+			}
+		} else if (p_tests || s_tests) {
+			char *msg = g_strdup_printf (">>> nmtst: ignore -p and -s options for tap-tests");
+
+			g_array_append_val (debug_messages, msg);
+		}
+
+		g_ptr_array_add (arg_array, NULL);
+
+		arg_array_n = arg_array->len - 1;
+		arg_array_c = (char **) g_ptr_array_free (arg_array, FALSE);
+
+		g_test_init (&arg_array_n, &arg_array_c, NULL);
+
+		if (*argc > 1) {
+			/* collaps argc/argv by removing the arguments detected
+			 * by g_test_init(). */
+			for (i = 1, j = 1; i < *argc; i++) {
+				if ((*argv)[i] == arg_array_c[j])
+					j++;
+				else
+					(*argv)[i] = NULL;
+			}
+			for (i = 1, j = 1; i < *argc; i++) {
+				if ((*argv)[i]) {
+					(*argv)[j++] = (*argv)[i];
+					if (i >= j)
+						(*argv)[i] = NULL;
+				}
+			}
+			*argc = j;
+		}
+
+		/* we must "leak" the test paths because they are not cloned by g_test_init(). */
+		if (!__nmtst_internal.test_tap_log) {
+			if (p_tests) {
+				p_tests_x = (char **) g_ptr_array_free (p_tests, FALSE);
+				p_tests = NULL;
+			}
+			if (s_tests) {
+				s_tests_x = (char **) g_ptr_array_free (s_tests, FALSE);
+				s_tests = NULL;
+			}
+		}
+	}
+
+	if (test_quick_set)
+		__nmtst_internal.test_quick = test_quick;
+	else if (test_quick_argv)
+		__nmtst_internal.test_quick = g_test_quick ();
+	else {
+#ifdef NMTST_TEST_QUICK
+		__nmtst_internal.test_quick = NMTST_TEST_QUICK;
+#else
+		__nmtst_internal.test_quick = FALSE;
+#endif
+	}
+
+	__nmtst_internal.is_debug = is_debug;
+	__nmtst_internal.rand0 = g_rand_new_with_seed (0);
+	__nmtst_internal.sudo_cmd = sudo_cmd;
+	__nmtst_internal.no_expect_message = no_expect_message;
+
+	if (!log_level && log_domains) {
+		/* if the log level is not specified (but the domain is), we assume
+		 * the caller wants to set it depending on is_debug */
+		log_level = is_debug ? "DEBUG" : "WARN";
+	}
+
+	if (!__nmtst_internal.assert_logging) {
+		gboolean success = TRUE;
+#ifdef _NMTST_INSIDE_CORE
+		success = nm_logging_setup (log_level, log_domains, NULL, NULL);
+		*out_set_logging = TRUE;
+#endif
+		g_assert (success);
+#if GLIB_CHECK_VERSION(2,34,0)
+		if (__nmtst_internal.no_expect_message)
+			g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#else
+		/* g_test_expect_message() is a NOP, so allow any messages */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#endif
+	} else if (__nmtst_internal.no_expect_message) {
+		/* We have a test that would be assert_logging, but the user specified no_expect_message.
+		 * This transforms g_test_expect_message() into a NOP, but we also have to relax
+		 * g_log_set_always_fatal(), which was set by g_test_init(). */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#ifdef _NMTST_INSIDE_CORE
+		if (c_log_domains || c_log_level) {
+			/* Normally, tests with assert_logging do not overwrite the logging level/domains because
+			 * the logging statements are part of the assertions. But if the test is run with
+			 * no-expect-message *and* the logging is set explicitly via environment variables,
+			 * we still reset the logging. */
+			gboolean success;
+
+			success = nm_logging_setup (log_level, log_domains, NULL, NULL);
+			*out_set_logging = TRUE;
+			g_assert (success);
+		}
+#endif
+	} else {
+#if GLIB_CHECK_VERSION(2,34,0)
+		/* We were called not to set logging levels. This means, that the user
+		 * expects to assert against (all) messages. Any uncought message is fatal. */
+		g_log_set_always_fatal (G_LOG_LEVEL_MASK);
+#else
+		/* g_test_expect_message() is a NOP, so allow any messages */
+		g_log_set_always_fatal (G_LOG_FATAL_MASK);
+#endif
+	}
+
+	if ((!__nmtst_internal.assert_logging || (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message)) &&
+	    (is_debug || (c_log_level && (!g_ascii_strcasecmp (c_log_level, "DEBUG") || !g_ascii_strcasecmp (c_log_level, "TRACE")))) &&
+	    !g_getenv ("G_MESSAGES_DEBUG"))
+	{
+		/* if we are @is_debug or @log_level=="DEBUG" and
+		 * G_MESSAGES_DEBUG is unset, we set G_MESSAGES_DEBUG=all.
+		 * To disable this default behaviour, set G_MESSAGES_DEBUG='' */
+
+		/* Note that g_setenv is not thread safe, but you should anyway call
+		 * nmtst_init() at the very start. */
+		g_setenv ("G_MESSAGES_DEBUG", "all", TRUE);
+	}
+
+	/* Delay messages until we setup logging. */
+	for (i = 0; i < debug_messages->len; i++)
+		__NMTST_LOG (g_message, "%s", g_array_index (debug_messages, const char *, i));
+
+	g_strfreev ((char **) g_array_free (debug_messages, FALSE));
+	g_free (c_log_level);
+	g_free (c_log_domains);
+
+#ifdef __NETWORKMANAGER_UTILS_H__
+	/* ensure that monotonic timestamp is called (because it initially logs a line) */
+	nm_utils_get_monotonic_timestamp_s ();
+#endif
+
+#ifdef NM_UTILS_H
+	{
+		gs_free_error GError *error = NULL;
+
+		if (!nm_utils_init (&error))
+			g_assert_not_reached ();
+		g_assert_no_error (error);
+	}
+#endif
+}
+
+#ifndef _NMTST_INSIDE_CORE
+inline static void
+nmtst_init (int *argc, char ***argv, gboolean assert_logging)
+{
+	__nmtst_init (argc, argv, assert_logging, NULL, NULL, NULL);
+}
+#endif
+
+inline static gboolean
+nmtst_is_debug (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.is_debug;
+}
+
+inline static gboolean
+nmtst_test_quick (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.test_quick;
+}
+
+#if GLIB_CHECK_VERSION(2,34,0)
+#undef g_test_expect_message
+#define g_test_expect_message(...) \
+	G_STMT_START { \
+		g_assert (nmtst_initialized ()); \
+		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) { \
+			g_debug ("nmtst: assert-logging: g_test_expect_message %s", G_STRINGIFY ((__VA_ARGS__))); \
+		} else { \
+			G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+			g_test_expect_message (__VA_ARGS__); \
+			G_GNUC_END_IGNORE_DEPRECATIONS \
+		} \
+	} G_STMT_END
+#undef g_test_assert_expected_messages_internal
+#define g_test_assert_expected_messages_internal(domain, file, line, func) \
+	G_STMT_START { \
+		const char *_domain = (domain); \
+		const char *_file = (file); \
+		const char *_func = (func); \
+		int _line = (line); \
+		\
+		if (__nmtst_internal.assert_logging && __nmtst_internal.no_expect_message) \
+			g_debug ("nmtst: assert-logging: g_test_assert_expected_messages(%s, %s:%d, %s)", _domain?:"", _file?:"", _line, _func?:""); \
+		\
+		G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+		g_test_assert_expected_messages_internal (_domain, _file, _line, _func); \
+		G_GNUC_END_IGNORE_DEPRECATIONS \
+	} G_STMT_END
+#endif
+
+/*****************************************************************************/
+
+typedef struct _NmtstTestData NmtstTestData;
+
+typedef void (*NmtstTestDataRelease) (const NmtstTestData *test_data);
+
+struct _NmtstTestData {
+	const char *testpath;
+	NmtstTestDataRelease fcn_release;
+	gsize n_args;
+	gpointer args[1];
+};
+
+inline static void
+_nmtst_test_data_unpack (const NmtstTestData *test_data, gsize n_args, ...)
+{
+	gsize i;
+	va_list ap;
+	gpointer *p;
+
+	g_assert (test_data);
+	g_assert_cmpint (n_args, ==, test_data->n_args);
+
+	va_start (ap, n_args);
+	for (i = 0; i < n_args; i++) {
+		p = va_arg (ap, gpointer *);
+
+		g_assert (p);
+		*p = test_data->args[i];
+	}
+	va_end (ap);
+}
+#define nmtst_test_data_unpack(test_data, ...) _nmtst_test_data_unpack(test_data, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
+
+inline static void
+_nmtst_test_data_free (gpointer data)
+{
+	NmtstTestData *test_data = data;
+
+	g_assert (test_data);
+
+	if (test_data->fcn_release)
+		test_data->fcn_release (test_data);
+
+	g_free ((gpointer) test_data->testpath);
+	g_free (test_data);
+}
+
+inline static void
+_nmtst_add_test_func_full (const char *testpath, GTestDataFunc test_func, NmtstTestDataRelease fcn_release, gsize n_args, ...)
+{
+	gsize i;
+	NmtstTestData *data;
+	va_list ap;
+
+	data = g_malloc (G_STRUCT_OFFSET (NmtstTestData, args) + sizeof (gpointer) * (n_args + 1));
+
+	data->testpath = g_strdup (testpath);
+	data->fcn_release = fcn_release;
+	data->n_args = n_args;
+	va_start (ap, n_args);
+	for (i = 0; i < n_args; i++)
+		data->args[i] = va_arg (ap, gpointer);
+	data->args[i] = NULL;
+	va_end (ap);
+
+	g_test_add_data_func_full (testpath,
+	                           data,
+	                           test_func,
+	                           _nmtst_test_data_free);
+}
+#define nmtst_add_test_func_full(testpath, test_func, fcn_release, ...) _nmtst_add_test_func_full(testpath, test_func, fcn_release, NM_NARG (__VA_ARGS__), ##__VA_ARGS__)
+#define nmtst_add_test_func(testpath, test_func, ...) nmtst_add_test_func_full(testpath, test_func, NULL, ##__VA_ARGS__)
+
+/*****************************************************************************/
+
+inline static GRand *
+nmtst_get_rand0 (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.rand0;
+}
+
+inline static GRand *
+nmtst_get_rand (void)
+{
+	g_assert (nmtst_initialized ());
+
+	if (G_UNLIKELY (!__nmtst_internal.rand)) {
+		guint32 seed;
+		const char *str;
+
+		if ((str = g_getenv ("NMTST_SEED_RAND"))) {
+			gchar *s;
+			gint64 i;
+
+			i = g_ascii_strtoll (str, &s, 0);
+			g_assert (s[0] == '\0' && i >= 0 && i < G_MAXUINT32);
+
+			seed = i;
+			__nmtst_internal.rand = g_rand_new_with_seed (seed);
+		} else {
+			__nmtst_internal.rand = g_rand_new ();
+
+			seed = g_rand_int (__nmtst_internal.rand);
+			g_rand_set_seed (__nmtst_internal.rand, seed);
+		}
+		__nmtst_internal.rand_seed = seed;
+
+		g_print ("\nnmtst: initialize nmtst_get_rand() with NMTST_SEED_RAND=%u\n", seed);
+	}
+	return __nmtst_internal.rand;
+}
+
+inline static guint32
+nmtst_get_rand_int (void)
+{
+	return g_rand_int (nmtst_get_rand ());
+}
+
+inline static gpointer
+nmtst_rand_buf (GRand *rand, gpointer buffer, gsize buffer_length)
+{
+	guint32 v;
+	guint8 *b = buffer;
+
+	if (!buffer_length)
+		return buffer;
+
+	g_assert (buffer);
+
+	if (!rand)
+		rand = nmtst_get_rand ();
+
+	for (; buffer_length >= sizeof (guint32); buffer_length -= sizeof (guint32), b += sizeof (guint32)) {
+		v = g_rand_int (rand);
+		memcpy (b, &v, sizeof (guint32));
+	}
+	if (buffer_length > 0) {
+		v = g_rand_int (rand);
+		do {
+			*(b++) = v & 0xFF;
+			v >>= 8;
+		} while (--buffer_length > 0);
+	}
+	return buffer;
+}
+
+inline static void *
+nmtst_rand_perm (GRand *rand, void *dst, const void *src, gsize elmt_size, gsize n_elmt)
+{
+	gsize i, j;
+	char *p_, *pj;
+	char *bu;
+
+	g_assert (dst);
+	g_assert (elmt_size > 0);
+	g_assert (n_elmt < G_MAXINT32);
+
+	if (n_elmt == 0)
+		return dst;
+
+	if (src && dst != src)
+		memcpy (dst, src, elmt_size * n_elmt);
+
+	if (!rand)
+		rand = nmtst_get_rand ();
+
+	bu = g_slice_alloc (elmt_size);
+
+	p_ = dst;
+	for (i = n_elmt; i > 1; i--) {
+		j = g_rand_int_range (rand, 0, i);
+
+		if (j != 0) {
+			pj = &p_[j * elmt_size];
+
+			/* swap */
+			memcpy (bu, p_, elmt_size);
+			memcpy (p_, pj, elmt_size);
+			memcpy (pj, bu, elmt_size);
+		}
+		p_ += elmt_size;
+	}
+
+	g_slice_free1 (elmt_size, bu);
+	return dst;
+}
+
+inline static GSList *
+nmtst_rand_perm_gslist (GRand *rand, GSList *list)
+{
+	GSList *result;
+	guint l;
+
+	if (!rand)
+		rand = nmtst_get_rand ();
+
+	/* no need for an efficient implementation :) */
+
+	result = 0;
+	for (l = g_slist_length (list); l > 0; l--) {
+		GSList *tmp;
+
+		tmp = g_slist_nth (list, g_rand_int (rand) % l);
+		g_assert (tmp);
+
+		list = g_slist_remove_link (list, tmp);
+		result = g_slist_concat (tmp, result);
+	}
+	g_assert (!list);
+	return result;
+}
+
+/*****************************************************************************/
+
+inline static gboolean
+_nmtst_main_loop_run_timeout (gpointer user_data)
+{
+	GMainLoop **p_loop = user_data;
+
+	g_assert (p_loop);
+	g_assert (*p_loop);
+
+	g_main_loop_quit (*p_loop);
+	*p_loop = NULL;
+
+	return G_SOURCE_REMOVE;
+}
+
+inline static gboolean
+nmtst_main_loop_run (GMainLoop *loop, int timeout_ms)
+{
+	GSource *source = NULL;
+	guint id = 0;
+	GMainLoop *loopx = loop;
+
+	if (timeout_ms > 0) {
+		source = g_timeout_source_new (timeout_ms);
+		g_source_set_callback (source, _nmtst_main_loop_run_timeout, &loopx, NULL);
+		id = g_source_attach (source, g_main_loop_get_context (loop));
+		g_assert (id);
+		g_source_unref (source);
+	}
+
+	g_main_loop_run (loop);
+
+	/* if the timeout was reached, return FALSE. */
+	return loopx != NULL;
+}
+
+inline static void
+_nmtst_main_loop_quit_on_notify (GObject *object, GParamSpec *pspec, gpointer user_data)
+{
+	GMainLoop *loop = user_data;
+
+	g_assert (G_IS_OBJECT (object));
+	g_assert (loop);
+
+	g_main_loop_quit (loop);
+}
+#define nmtst_main_loop_quit_on_notify ((GCallback) _nmtst_main_loop_quit_on_notify)
+
+/*****************************************************************************/
+
+inline static const char *
+nmtst_get_sudo_cmd (void)
+{
+	g_assert (nmtst_initialized ());
+	return __nmtst_internal.sudo_cmd;
+}
+
+inline static void
+nmtst_reexec_sudo (void)
+{
+	char *str;
+	char **argv;
+	int i;
+	int errsv;
+
+	g_assert (nmtst_initialized ());
+	g_assert (__nmtst_internal.orig_argv);
+
+	if (!__nmtst_internal.sudo_cmd)
+		return;
+
+	str = g_strjoinv (" ", __nmtst_internal.orig_argv);
+	__NMTST_LOG (g_message, ">> exec %s %s", __nmtst_internal.sudo_cmd, str);
+
+	argv = g_new0 (char *, 1 + g_strv_length (__nmtst_internal.orig_argv) + 1);
+	argv[0] = __nmtst_internal.sudo_cmd;
+	for (i = 0; __nmtst_internal.orig_argv[i]; i++)
+		argv[i+1] = __nmtst_internal.orig_argv[i];
+
+	execvp (__nmtst_internal.sudo_cmd, argv);
+
+	errsv = errno;
+	g_error (">> exec %s failed: %d - %s", __nmtst_internal.sudo_cmd, errsv, strerror (errsv));
+}
+
+/*****************************************************************************/
+
+inline static gsize
+nmtst_find_all_indexes (gpointer *elements,
+                        gsize n_elements,
+                        gpointer *needles,
+                        gsize n_needles,
+                        gboolean (*equal_fcn) (gpointer element, gpointer needle, gpointer user_data),
+                        gpointer user_data,
+                        gssize *out_idx)
+{
+	gsize i, j, k;
+	gsize found = 0;
+
+	for (i = 0; i < n_needles; i++) {
+		gssize idx = -1;
+
+		for (j = 0; j < n_elements; j++) {
+
+			/* no duplicates */
+			for (k = 0; k < i; k++) {
+				if (out_idx[k] == j)
+					goto next;
+			}
+
+			if (equal_fcn (elements[j], needles[i], user_data)) {
+				idx = j;
+				break;
+			}
+next:
+			;
+		}
+
+		out_idx[i] = idx;
+		if (idx >= 0)
+			found++;
+	}
+
+	return found;
+}
+
+/*****************************************************************************/
+
+#define __define_nmtst_static(NUM,SIZE) \
+inline static const char * \
+nmtst_static_##SIZE##_##NUM (const char *str) \
+{ \
+	gsize l; \
+	static char buf[SIZE]; \
+\
+	if (!str) \
+		return NULL; \
+	l = g_strlcpy (buf, str, sizeof (buf)); \
+	g_assert (l < sizeof (buf)); \
+	return buf; \
+}
+__define_nmtst_static(01, 1024)
+__define_nmtst_static(02, 1024)
+__define_nmtst_static(03, 1024)
+#undef __define_nmtst_static
+
+#define NMTST_UUID_INIT(uuid) \
+	gs_free char *_nmtst_hidden_##uuid = nm_utils_uuid_generate (); \
+	const char *const uuid = _nmtst_hidden_##uuid
+
+inline static const char *
+nmtst_uuid_generate (void)
+{
+	static char u[37];
+	gs_free char *m = NULL;
+
+	m = nm_utils_uuid_generate ();
+	g_assert (m && strlen (m) == sizeof (u) - 1);
+	memcpy (u, m, sizeof (u));
+	return u;
+}
+
+#define NMTST_SWAP(x,y) \
+	G_STMT_START { \
+		char __nmtst_swap_temp[sizeof(x) == sizeof(y) ? (signed) sizeof(x) : -1]; \
+		memcpy(__nmtst_swap_temp, &y, sizeof(x)); \
+		memcpy(&y,                &x, sizeof(x)); \
+		memcpy(&x, __nmtst_swap_temp, sizeof(x)); \
+	} G_STMT_END
+
+#define nmtst_assert_str_has_substr(str, substr) \
+	G_STMT_START { \
+		const char *__str = (str); \
+		const char *__substr = (substr); \
+		\
+		g_assert (__str); \
+		g_assert (__substr); \
+		if (strstr (__str, __substr) == NULL) \
+			g_error ("%s:%d: Expects \"%s\" but got \"%s\"", __FILE__, __LINE__, __substr, __str); \
+	} G_STMT_END
+
+inline static guint32
+nmtst_inet4_from_string (const char *str)
+{
+	guint32 addr;
+	int success;
+
+	if (!str)
+		return 0;
+
+	success = inet_pton (AF_INET, str, &addr);
+
+	g_assert (success == 1);
+
+	return addr;
+}
+
+inline static const struct in6_addr *
+nmtst_inet6_from_string (const char *str)
+{
+	static struct in6_addr addr;
+	int success;
+
+	if (!str)
+		addr = in6addr_any;
+	else {
+		success = inet_pton (AF_INET6, str, &addr);
+		g_assert (success == 1);
+	}
+
+	return &addr;
+}
+
+inline static void
+_nmtst_assert_ip4_address (const char *file, int line, in_addr_t addr, const char *str_expected)
+{
+	if (nmtst_inet4_from_string (str_expected) != addr) {
+		char buf[100];
+
+		g_error ("%s:%d: Unexpected IPv4 address: expected %s, got %s",
+		         file, line, str_expected ? str_expected : "0.0.0.0",
+		         inet_ntop (AF_INET, &addr, buf, sizeof (buf)));
+	}
+}
+#define nmtst_assert_ip4_address(addr, str_expected) _nmtst_assert_ip4_address (__FILE__, __LINE__, addr, str_expected)
+
+inline static void
+_nmtst_assert_ip6_address (const char *file, int line, const struct in6_addr *addr, const char *str_expected)
+{
+	struct in6_addr any = in6addr_any;
+
+	if (!addr)
+		addr = &any;
+
+	if (memcmp (nmtst_inet6_from_string (str_expected), addr, sizeof (*addr)) != 0) {
+		char buf[100];
+
+		g_error ("%s:%d: Unexpected IPv6 address: expected %s, got %s",
+		         file, line, str_expected ? str_expected : "::",
+		         inet_ntop (AF_INET6, addr, buf, sizeof (buf)));
+	}
+}
+#define nmtst_assert_ip6_address(addr, str_expected) _nmtst_assert_ip6_address (__FILE__, __LINE__, addr, str_expected)
+
+#define nmtst_spawn_sync(working_directory, standard_out, standard_err, assert_exit_status, ...) \
+	__nmtst_spawn_sync (working_directory, standard_out, standard_err, assert_exit_status, ##__VA_ARGS__, NULL)
+inline static gint
+__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...) G_GNUC_NULL_TERMINATED;
+inline static gint
+__nmtst_spawn_sync (const char *working_directory, char **standard_out, char **standard_err, int assert_exit_status, ...)
+{
+	gint exit_status = 0;
+	GError *error = NULL;
+	char *arg;
+	va_list va_args;
+	GPtrArray *argv = g_ptr_array_new ();
+	gboolean success;
+
+	va_start (va_args, assert_exit_status);
+	while ((arg = va_arg (va_args, char *)))
+		g_ptr_array_add (argv, arg);
+	va_end (va_args);
+
+	g_assert (argv->len >= 1);
+	g_ptr_array_add (argv, NULL);
+
+	success = g_spawn_sync (working_directory,
+	                        (char**) argv->pdata,
+	                        NULL,
+	                        0 /*G_SPAWN_DEFAULT*/,
+	                        NULL,
+	                        NULL,
+	                        standard_out,
+	                        standard_err,
+	                        &exit_status,
+	                        &error);
+	if (!success)
+		g_error ("nmtst_spawn_sync(%s): %s", ((char **) argv->pdata)[0], error->message);
+	g_assert (!error);
+
+	g_assert (!standard_out || *standard_out);
+	g_assert (!standard_err || *standard_err);
+
+	if (assert_exit_status != -1) {
+		/* exit status is a guint8 on success. Set @assert_exit_status to -1
+		 * not to check for the exit status. */
+		g_assert (WIFEXITED (exit_status));
+		g_assert_cmpint (WEXITSTATUS (exit_status), ==, assert_exit_status);
+	}
+
+	g_ptr_array_free (argv, TRUE);
+	return exit_status;
+}
+
+/*****************************************************************************/
+
+inline static char *
+nmtst_file_resolve_relative_path (const char *rel, const char *cwd)
+{
+	gs_free char *cwd_free = NULL;
+
+	g_assert (rel && *rel);
+
+	if (g_path_is_absolute (rel))
+		return g_strdup (rel);
+
+	if (!cwd)
+		cwd = cwd_free = g_get_current_dir ();
+	return g_build_filename (cwd, rel, NULL);
+}
+
+inline static char *
+nmtst_file_get_contents (const char *filename)
+{
+	GError *error = NULL;
+	gboolean success;
+	char *contents = NULL;
+	gsize len;
+
+	success = g_file_get_contents (filename, &contents, &len, &error);
+	nmtst_assert_success (success && contents, error);
+	g_assert_cmpint (strlen (contents), ==, len);
+	return contents;
+}
+
+/*****************************************************************************/
+
+inline static void
+nmtst_file_unlink_if_exists (const char *name)
+{
+	int errsv;
+
+	g_assert (name && name[0]);
+
+	if (unlink (name) != 0) {
+		errsv = errno;
+		if (errsv != ENOENT)
+			g_error ("nmtst_file_unlink_if_exists(%s): failed with %s", name, strerror (errsv));
+	}
+}
+
+inline static void
+nmtst_file_unlink (const char *name)
+{
+	int errsv;
+
+	g_assert (name && name[0]);
+
+	if (unlink (name) != 0) {
+		errsv = errno;
+		g_error ("nmtst_file_unlink(%s): failed with %s", name, strerror (errsv));
+	}
+}
+
+inline static void
+_nmtst_auto_unlinkfile (char **p_name)
+{
+	if (*p_name) {
+		nmtst_file_unlink (*p_name);
+		nm_clear_g_free (p_name);
+	}
+}
+
+#define nmtst_auto_unlinkfile nm_auto(_nmtst_auto_unlinkfile)
+
+/*****************************************************************************/
+
+inline static void
+_nmtst_assert_resolve_relative_path_equals (const char *f1, const char *f2, const char *file, int line)
+{
+	gs_free char *p1 = NULL, *p2 = NULL;
+
+	p1 = nmtst_file_resolve_relative_path (f1, NULL);
+	p2 = nmtst_file_resolve_relative_path (f2, NULL);
+	g_assert (p1 && *p1);
+
+	/* Fixme: later we might need to coalesce repeated '/', "./", and "../".
+	 * For now, it's good enough. */
+	if (g_strcmp0 (p1, p2) != 0)
+		g_error ("%s:%d : filenames don't match \"%s\" vs. \"%s\" // \"%s\" - \"%s\"", file, line, f1, f2, p1, p2);
+}
+#define nmtst_assert_resolve_relative_path_equals(f1, f2) _nmtst_assert_resolve_relative_path_equals (f1, f2, __FILE__, __LINE__);
+
+/*****************************************************************************/
+
+#ifdef NM_SETTING_IP_CONFIG_H
+inline static void
+nmtst_setting_ip_config_add_address (NMSettingIPConfig *s_ip,
+                                     const char *address,
+                                     guint prefix)
+{
+	NMIPAddress *addr;
+	int family;
+
+	g_assert (s_ip);
+
+	if (nm_utils_ipaddr_valid (AF_INET, address))
+		family = AF_INET;
+	else if (nm_utils_ipaddr_valid (AF_INET6, address))
+		family = AF_INET6;
+	else
+		g_assert_not_reached ();
+
+	addr = nm_ip_address_new (family, address, prefix, NULL);
+	g_assert (addr);
+	g_assert (nm_setting_ip_config_add_address (s_ip, addr));
+	nm_ip_address_unref (addr);
+}
+
+inline static void
+nmtst_setting_ip_config_add_route (NMSettingIPConfig *s_ip,
+                                   const char *dest,
+                                   guint prefix,
+                                   const char *next_hop,
+                                   gint64 metric)
+{
+	NMIPRoute *route;
+	int family;
+
+	g_assert (s_ip);
+
+	if (nm_utils_ipaddr_valid (AF_INET, dest))
+		family = AF_INET;
+	else if (nm_utils_ipaddr_valid (AF_INET6, dest))
+		family = AF_INET6;
+	else
+		g_assert_not_reached ();
+
+	route = nm_ip_route_new (family, dest, prefix, next_hop, metric, NULL);
+	g_assert (route);
+	g_assert (nm_setting_ip_config_add_route (s_ip, route));
+	nm_ip_route_unref (route);
+}
+#endif /* NM_SETTING_IP_CONFIG_H */
+
+#if (defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__)) || (defined(NM_CONNECTION_H))
+
+inline static NMConnection *
+nmtst_clone_connection (NMConnection *connection)
+{
+	g_assert (NM_IS_CONNECTION (connection));
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+	return nm_simple_connection_new_clone (connection);
+#else
+	return nm_connection_duplicate (connection);
+#endif
+}
+
+inline static NMConnection *
+nmtst_create_minimal_connection (const char *id, const char *uuid, const char *type, NMSettingConnection **out_s_con)
+{
+	NMConnection *con;
+	NMSetting *s_base = NULL;
+	NMSettingConnection *s_con;
+	gs_free char *uuid_free = NULL;
+
+	g_assert (id);
+
+	if (uuid)
+		g_assert (nm_utils_is_uuid (uuid));
+	else
+		uuid = uuid_free = nm_utils_uuid_generate ();
+
+	if (type) {
+		GType type_g;
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+		type_g = nm_setting_lookup_type (type);
+#else
+		type_g = nm_connection_lookup_setting_type (type);
+#endif
+
+		g_assert (type_g != G_TYPE_INVALID);
+
+		s_base = g_object_new (type_g, NULL);
+		g_assert (NM_IS_SETTING (s_base));
+	}
+
+#if defined(__NM_SIMPLE_CONNECTION_H__)
+	con = nm_simple_connection_new ();
+#else
+	con = nm_connection_new ();
+#endif
+
+	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, id,
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_TYPE, type,
+	              NULL);
+	nm_connection_add_setting (con, NM_SETTING (s_con));
+
+	if (s_base)
+		nm_connection_add_setting (con, s_base);
+
+	if (out_s_con)
+		*out_s_con = s_con;
+	return con;
+}
+
+inline static gboolean
+_nmtst_connection_normalize_v (NMConnection *connection, va_list args)
+{
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	GHashTable *parameters = NULL;
+	const char *p_name;
+
+	g_assert (NM_IS_CONNECTION (connection));
+
+	while ((p_name = va_arg (args, const char *))) {
+		if (!parameters)
+			parameters =  g_hash_table_new (g_str_hash, g_str_equal);
+		g_hash_table_insert (parameters, (gpointer *) p_name, va_arg (args, gpointer));
+	}
+
+	success = nm_connection_normalize (connection,
+	                                   parameters,
+	                                   &was_modified,
+	                                   &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	if (parameters)
+		g_hash_table_destroy (parameters);
+
+	return was_modified;
+}
+
+inline static gboolean
+_nmtst_connection_normalize (NMConnection *connection, ...)
+{
+	gboolean was_modified;
+	va_list args;
+
+	va_start (args, connection);
+	was_modified = _nmtst_connection_normalize_v (connection, args);
+	va_end (args);
+
+	return was_modified;
+}
+#define nmtst_connection_normalize(connection, ...) \
+    _nmtst_connection_normalize(connection, ##__VA_ARGS__, NULL)
+
+inline static NMConnection *
+_nmtst_connection_duplicate_and_normalize (NMConnection *connection, ...)
+{
+	gboolean was_modified;
+	va_list args;
+
+	connection = nmtst_clone_connection (connection);
+
+	va_start (args, connection);
+	was_modified = _nmtst_connection_normalize_v (connection, args);
+	va_end (args);
+
+	return connection;
+}
+#define nmtst_connection_duplicate_and_normalize(connection, ...) \
+    _nmtst_connection_duplicate_and_normalize(connection, ##__VA_ARGS__, NULL)
+
+inline static void
+nmtst_assert_connection_equals (NMConnection *a, gboolean normalize_a, NMConnection *b, gboolean normalize_b)
+{
+	gboolean compare;
+	gs_unref_object NMConnection *a2 = NULL;
+	gs_unref_object NMConnection *b2 = NULL;
+	GHashTable *out_settings = NULL;
+
+	g_assert (NM_IS_CONNECTION (a));
+	g_assert (NM_IS_CONNECTION (b));
+
+	if (normalize_a)
+		a = a2 = nmtst_connection_duplicate_and_normalize (a);
+	if (normalize_b)
+		b = b2 = nmtst_connection_duplicate_and_normalize (b);
+
+	compare = nm_connection_diff (a, b, NM_SETTING_COMPARE_FLAG_EXACT, &out_settings);
+	if (!compare || out_settings) {
+		const char *name, *pname;
+		GHashTable *setting;
+		GHashTableIter iter, iter2;
+
+		__NMTST_LOG (g_message, ">>> ASSERTION nmtst_assert_connection_equals() fails");
+		if (out_settings) {
+			g_hash_table_iter_init (&iter, out_settings);
+			while (g_hash_table_iter_next (&iter, (gpointer *) &name, (gpointer *) &setting)) {
+				__NMTST_LOG (g_message, ">>> differences in setting '%s':", name);
+
+				g_hash_table_iter_init (&iter2, setting);
+				while (g_hash_table_iter_next (&iter2, (gpointer *) &pname, NULL))
+					__NMTST_LOG (g_message, ">>> differences in setting '%s.%s'", name, pname);
+			}
+		}
+
+#ifdef __NM_KEYFILE_INTERNAL_H__
+		{
+			gs_unref_keyfile GKeyFile *kf_a = NULL, *kf_b = NULL;
+			gs_free char *str_a = NULL, *str_b = NULL;
+
+			kf_a = nm_keyfile_write (a, NULL, NULL, NULL);
+			kf_b = nm_keyfile_write (b, NULL, NULL, NULL);
+
+			if (kf_a)
+				str_a = g_key_file_to_data (kf_a, NULL, NULL);
+			if (kf_b)
+				str_b = g_key_file_to_data (kf_b, NULL, NULL);
+
+			__NMTST_LOG (g_message, ">>> Connection A as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_a);
+			__NMTST_LOG (g_message, ">>> Connection B as kf (*WARNING: keyfile representation might not show the difference*):\n%s", str_b);
+		}
+#endif
+	}
+	g_assert (compare);
+	g_assert (!out_settings);
+
+	compare = nm_connection_compare (a, b, NM_SETTING_COMPARE_FLAG_EXACT);
+	g_assert (compare);
+}
+
+inline static void
+nmtst_assert_connection_verifies (NMConnection *con)
+{
+	/* assert that the connection does verify, it might be normaliziable or not */
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_CONNECTION (con));
+
+	success = nm_connection_verify (con, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+}
+
+inline static void
+nmtst_assert_connection_verifies_without_normalization (NMConnection *con)
+{
+	/* assert that the connection verifies and does not need any normalization */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	nmtst_assert_connection_verifies (con);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
+	g_assert (!was_modified);
+}
+
+inline static void
+nmtst_assert_connection_verifies_and_normalizable (NMConnection *con)
+{
+	/* assert that the connection does verify, but normalization still modifies it */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	nmtst_assert_connection_verifies (con);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (was_modified);
+
+	/* again! */
+	nmtst_assert_connection_verifies_without_normalization (clone);
+}
+
+inline static void
+nmtst_assert_connection_verifies_after_normalization (NMConnection *con,
+                                                      GQuark expect_error_domain,
+                                                      gint expect_error_code)
+{
+	/* assert that the connection does not verify, but normalization does fix it */
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	success = nm_connection_verify (con, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (was_modified);
+
+	/* again! */
+	nmtst_assert_connection_verifies_without_normalization (clone);
+}
+
+inline static void
+nmtst_assert_connection_unnormalizable (NMConnection *con,
+                                        GQuark expect_error_domain,
+                                        gint expect_error_code)
+{
+	/* assert that the connection does not verify, and it cannot be fixed by normalization */
+
+	GError *error = NULL;
+	gboolean success;
+	gboolean was_modified = FALSE;
+	gs_unref_object NMConnection *clone = NULL;
+
+	clone = nmtst_clone_connection (con);
+
+	success = nm_connection_verify (con, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+
+	success = nm_connection_normalize (clone, NULL, &was_modified, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_assert (!was_modified);
+	nmtst_assert_connection_equals (con, FALSE, clone, FALSE);
+	g_clear_error (&error);
+}
+
+inline static void
+nmtst_assert_setting_verifies (NMSetting *setting)
+{
+	/* assert that the setting verifies without an error */
+
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_SETTING (setting));
+
+	success = nm_setting_verify (setting, NULL, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+}
+
+inline static void
+nmtst_assert_setting_verify_fails (NMSetting *setting,
+                                   GQuark expect_error_domain,
+                                   gint expect_error_code)
+{
+	/* assert that the setting verification fails */
+
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (NM_IS_SETTING (setting));
+
+	success = nm_setting_verify (setting, NULL, &error);
+	nmtst_assert_error (error, expect_error_domain, expect_error_code, NULL);
+	g_assert (!success);
+	g_clear_error (&error);
+}
+
+#endif
+
+#ifdef __NM_UTILS_H__
+static inline void
+nmtst_assert_hwaddr_equals (gconstpointer hwaddr1, gssize hwaddr1_len, const char *expected, const char *file, int line)
+{
+	guint8 buf2[NM_UTILS_HWADDR_LEN_MAX];
+	gsize hwaddr2_len = 1;
+	const char *p;
+	gboolean success;
+
+	g_assert (hwaddr1_len > 0 && hwaddr1_len <= NM_UTILS_HWADDR_LEN_MAX);
+
+	g_assert (expected);
+	for (p = expected; *p; p++) {
+		if (*p == ':' || *p == '-')
+			hwaddr2_len++;
+	}
+	g_assert (hwaddr2_len <= NM_UTILS_HWADDR_LEN_MAX);
+	g_assert (nm_utils_hwaddr_aton (expected, buf2, hwaddr2_len));
+
+	/* Manually check the entire hardware address instead of using
+	 * nm_utils_hwaddr_matches() because that function doesn't compare
+	 * entire InfiniBand addresses for various (legitimate) reasons.
+	 */
+	success = (hwaddr1_len == hwaddr2_len);
+	if (success)
+		success = !memcmp (hwaddr1, buf2, hwaddr1_len);
+	if (!success) {
+		g_error ("assert: %s:%d: hwaddr '%s' (%zd) expected, but got %s (%zd)",
+		         file, line, expected, hwaddr2_len, nm_utils_hwaddr_ntoa (hwaddr1, hwaddr1_len), hwaddr1_len);
+	}
+}
+#define nmtst_assert_hwaddr_equals(hwaddr1, hwaddr1_len, expected) \
+    nmtst_assert_hwaddr_equals (hwaddr1, hwaddr1_len, expected, __FILE__, __LINE__)
+#endif
+
+#if defined(__NM_SIMPLE_CONNECTION_H__) && defined(__NM_SETTING_CONNECTION_H__) && defined(__NM_KEYFILE_INTERNAL_H__)
+
+inline static NMConnection *
+nmtst_create_connection_from_keyfile (const char *keyfile_str, const char *keyfile_name, const char *base_dir)
+{
+	GKeyFile *keyfile;
+	GError *error = NULL;
+	gboolean success;
+	NMConnection *con;
+
+	g_assert (keyfile_str);
+
+	keyfile =  g_key_file_new ();
+	success = g_key_file_load_from_data (keyfile, keyfile_str, strlen (keyfile_str), G_KEY_FILE_NONE, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	con = nm_keyfile_read (keyfile, keyfile_name, base_dir, NULL, NULL, &error);
+	g_assert_no_error (error);
+	g_assert (NM_IS_CONNECTION (con));
+
+	g_key_file_unref (keyfile);
+
+	nmtst_connection_normalize (con);
+
+	return con;
+}
+
+#endif
+
+#ifdef __NM_CONNECTION_H__
+
+inline static GVariant *
+_nmtst_variant_new_vardict (int dummy, ...)
+{
+	GVariantBuilder builder;
+	va_list ap;
+	const char *name;
+	GVariant *variant;
+
+	g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);
+
+	va_start (ap, dummy);
+	while ((name = va_arg (ap, const char *))) {
+		variant = va_arg (ap, GVariant *);
+		g_variant_builder_add (&builder, "{sv}", name, variant);
+	}
+	va_end (ap);
+
+	return g_variant_builder_end (&builder);
+}
+#define nmtst_variant_new_vardict(...) _nmtst_variant_new_vardict (0, __VA_ARGS__, NULL)
+
+#define nmtst_assert_variant_is_of_type(variant, type) \
+	G_STMT_START { \
+		GVariant *_variantx = (variant); \
+		\
+		g_assert (_variantx); \
+		g_assert (g_variant_is_of_type (_variantx, (type))); \
+	} G_STMT_END
+
+#define nmtst_assert_variant_uint32(variant, val) \
+	G_STMT_START { \
+		GVariant *_variant = (variant); \
+		\
+		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_UINT32); \
+		g_assert_cmpint (g_variant_get_uint32 (_variant), ==, (val)); \
+	} G_STMT_END
+
+#define nmtst_assert_variant_string(variant, str) \
+	G_STMT_START { \
+		gsize _l; \
+		GVariant *_variant = (variant); \
+		const char *_str = (str); \
+		\
+		nmtst_assert_variant_is_of_type (_variant, G_VARIANT_TYPE_STRING); \
+		g_assert (_str); \
+		g_assert_cmpstr (g_variant_get_string (_variant, &_l), ==, _str); \
+		g_assert_cmpint (_l, ==, strlen (_str)); \
+	} G_STMT_END
+
+typedef enum {
+	NMTST_VARIANT_EDITOR_CONNECTION,
+	NMTST_VARIANT_EDITOR_SETTING,
+	NMTST_VARIANT_EDITOR_PROPERTY
+} NmtstVariantEditorPhase;
+
+#define NMTST_VARIANT_EDITOR(__connection_variant, __code) \
+	G_STMT_START { \
+		GVariantIter __connection_iter, *__setting_iter; \
+		GVariantBuilder __connection_builder, __setting_builder; \
+		const char *__cur_setting_name, *__cur_property_name; \
+		GVariant *__property_val; \
+		NmtstVariantEditorPhase __phase; \
+                                                                        \
+		g_variant_builder_init (&__connection_builder, NM_VARIANT_TYPE_CONNECTION); \
+		g_variant_iter_init (&__connection_iter, __connection_variant); \
+		 \
+		__phase = NMTST_VARIANT_EDITOR_CONNECTION; \
+		__cur_setting_name = NULL; \
+		__cur_property_name = NULL; \
+		__code; \
+		while (g_variant_iter_next (&__connection_iter, "{&sa{sv}}", &__cur_setting_name, &__setting_iter)) { \
+			g_variant_builder_init (&__setting_builder, NM_VARIANT_TYPE_SETTING); \
+			__phase = NMTST_VARIANT_EDITOR_SETTING; \
+			__cur_property_name = NULL; \
+			__code; \
+			 \
+			while (   __cur_setting_name \
+			       && g_variant_iter_next (__setting_iter, "{&sv}", &__cur_property_name, &__property_val)) { \
+				__phase = NMTST_VARIANT_EDITOR_PROPERTY; \
+				__code; \
+				 \
+				if (__cur_property_name) { \
+					g_variant_builder_add (&__setting_builder, "{sv}", \
+					                       __cur_property_name, \
+					                       __property_val); \
+				} \
+				g_variant_unref (__property_val); \
+			} \
+			 \
+			if (__cur_setting_name) \
+				g_variant_builder_add (&__connection_builder, "{sa{sv}}", __cur_setting_name, &__setting_builder); \
+			else \
+				g_variant_builder_clear (&__setting_builder); \
+			g_variant_iter_free (__setting_iter); \
+		} \
+		 \
+		g_variant_unref (__connection_variant); \
+		 \
+		__connection_variant = g_variant_builder_end (&__connection_builder); \
+	} G_STMT_END;
+
+#define NMTST_VARIANT_ADD_SETTING(__setting_name, __setting_variant) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_CONNECTION) \
+			g_variant_builder_add (&__connection_builder, "{s@a{sv}}", __setting_name, __setting_variant); \
+	} G_STMT_END
+
+#define NMTST_VARIANT_DROP_SETTING(__setting_name) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_SETTING && __cur_setting_name) { \
+			if (!strcmp (__cur_setting_name, __setting_name)) \
+				__cur_setting_name = NULL; \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_ADD_PROPERTY(__setting_name, __property_name, __format_string, __value) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_SETTING) { \
+			if (!strcmp (__cur_setting_name, __setting_name)) { \
+				g_variant_builder_add (&__setting_builder, "{sv}", __property_name, \
+				                       g_variant_new (__format_string, __value)); \
+			} \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_DROP_PROPERTY(__setting_name, __property_name) \
+	G_STMT_START { \
+		if (__phase == NMTST_VARIANT_EDITOR_PROPERTY && __cur_property_name) { \
+			if (   !strcmp (__cur_setting_name, __setting_name) \
+			    && !strcmp (__cur_property_name, __property_name)) \
+				__cur_property_name = NULL; \
+		} \
+	} G_STMT_END
+
+#define NMTST_VARIANT_CHANGE_PROPERTY(__setting_name, __property_name, __format_string, __value) \
+	G_STMT_START { \
+		NMTST_VARIANT_DROP_PROPERTY (__setting_name, __property_name); \
+		NMTST_VARIANT_ADD_PROPERTY (__setting_name, __property_name, __format_string, __value); \
+	} G_STMT_END
+
+#endif /* __NM_CONNECTION_H__ */
+
+#endif /* __NM_TEST_UTILS_H__ */
diff --git a/shared/nm-utils/nm-vpn-plugin-macros.h b/shared/nm-utils/nm-vpn-plugin-macros.h
new file mode 100644
index 0000000..acc549f
--- /dev/null
+++ b/shared/nm-utils/nm-vpn-plugin-macros.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2016 Red Hat, Inc.
+ */
+
+#ifndef __NM_VPN_PLUGIN_MACROS_H__
+#define __NM_VPN_PLUGIN_MACROS_H__
+
+#include <syslog.h>
+
+static inline int
+nm_utils_syslog_coerce_from_nm (int syslog_level)
+{
+	/* NetworkManager uses internally NMLogLevel levels. When spawning
+	 * the VPN plugin, it maps those levels to syslog levels as follows:
+	 *
+	 *  LOGL_INFO = LOG_NOTICE,
+	 *  LOGL_DEBUG = LOG_INFO,
+	 *  LOGL_TRACE = LOG_DEBUG,
+	 *
+	 * However, when actually printing to syslog, we don't want to print messages
+	 * with LOGL_INFO level as LOG_NOTICE, because they are *not* to be highlighted.
+	 *
+	 * In other words: NetworkManager has 3 levels that should not require highlighting:
+	 * LOGL_INFO, LOGL_DEBUG, LOGL_TRACE. syslog on the other hand has only LOG_INFO and LOG_DEBUG.
+	 *
+	 * So, coerce those values before printing to syslog. When you receive the syslog_level
+	 * from NetworkManager, instead of calling
+	 *   syslog(syslog_level, ...)
+	 * you should call
+	 *   syslog(nm_utils_syslog_coerce_from_nm(syslog_level), ...)
+	 */
+	switch (syslog_level) {
+	case LOG_INFO:
+		return LOG_DEBUG;
+	case LOG_NOTICE:
+		return LOG_INFO;
+	default:
+		return syslog_level;
+	}
+}
+
+static inline const char *
+nm_utils_syslog_to_str (int syslog_level)
+{
+	/* Maps the levels the same way as NetworkManager's nm-logging.c does */
+	if (syslog_level >= LOG_DEBUG)
+		return "<trace>";
+	if (syslog_level >= LOG_INFO)
+		return "<debug>";
+	if (syslog_level >= LOG_NOTICE)
+		return "<info>";
+	if (syslog_level >= LOG_WARNING)
+		return "<warn>";
+	return "<error>";
+}
+
+/*****************************************************************************/
+
+/* possibly missing defines from newer libnm API. */
+
+#ifndef NM_VPN_PLUGIN_CONFIG_PROXY_PAC
+#define NM_VPN_PLUGIN_CONFIG_PROXY_PAC "pac"
+#endif
+
+#ifndef NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES
+#define NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES "preserve-routes"
+#endif
+
+#ifndef NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES
+#define NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES "preserve-routes"
+#endif
+
+/*****************************************************************************/
+
+#endif /* __NM_VPN_PLUGIN_MACROS_H__ */
+
diff --git a/shared/nm-utils/nm-vpn-plugin-utils.c b/shared/nm-utils/nm-vpn-plugin-utils.c
new file mode 100644
index 0000000..353a281
--- /dev/null
+++ b/shared/nm-utils/nm-vpn-plugin-utils.c
@@ -0,0 +1,152 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2016,2018 Red Hat, Inc.
+ */
+
+#include "nm-default.h"
+
+#include "nm-vpn-plugin-utils.h"
+
+#include <dlfcn.h>
+
+/*****************************************************************************/
+
+NMVpnEditor *
+nm_vpn_plugin_utils_load_editor (const char *module_name,
+                                 const char *factory_name,
+                                 NMVpnPluginUtilsEditorFactory editor_factory,
+                                 NMVpnEditorPlugin *editor_plugin,
+                                 NMConnection *connection,
+                                 gpointer user_data,
+                                 GError **error)
+
+{
+	static struct {
+		gpointer factory;
+		void *dl_module;
+		char *module_name;
+		char *factory_name;
+	} cached = { 0 };
+	NMVpnEditor *editor;
+	gs_free char *module_path = NULL;
+	gs_free char *dirname = NULL;
+	Dl_info plugin_info;
+
+	g_return_val_if_fail (module_name, NULL);
+	g_return_val_if_fail (factory_name && factory_name[0], NULL);
+	g_return_val_if_fail (editor_factory, NULL);
+	g_return_val_if_fail (NM_IS_VPN_EDITOR_PLUGIN (editor_plugin), NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	g_return_val_if_fail (!error || !*error, NULL);
+
+	if (!g_path_is_absolute (module_name)) {
+		/*
+		 * Load an editor from the same directory this plugin is in.
+		 * Ideally, we'd get our .so name from the NMVpnEditorPlugin if it
+		 * would just have a property with it...
+		 */
+		if (!dladdr(nm_vpn_plugin_utils_load_editor, &plugin_info)) {
+			/* Really a "can not happen" scenario. */
+			g_set_error (error,
+			             NM_VPN_PLUGIN_ERROR,
+			             NM_VPN_PLUGIN_ERROR_FAILED,
+			             _("unable to get editor plugin name: %s"), dlerror ());
+		}
+
+		dirname = g_path_get_dirname (plugin_info.dli_fname);
+		module_path = g_build_filename (dirname, module_name, NULL);
+	} else {
+		module_path = g_strdup (module_name);
+	}
+
+	/* we really expect this function to be called with unchanging @module_name
+	 * and @factory_name. And we only want to load the module once, hence it would
+	 * be more complicated to accept changing @module_name/@factory_name arguments.
+	 *
+	 * The reason for only loading once is that due to glib types, we cannot create a
+	 * certain type-name more then once, so loading the same module or another version
+	 * of the same module will fail horribly as both try to create a GType with the same
+	 * name.
+	 *
+	 * Only support loading once, any future calls will reuse the handle. To simplify
+	 * that, we enforce that the @factory_name and @module_name is the same. */
+	if (cached.factory) {
+		g_return_val_if_fail (cached.dl_module, NULL);
+		g_return_val_if_fail (cached.factory_name && nm_streq0 (cached.factory_name, factory_name), NULL);
+		g_return_val_if_fail (cached.module_name && nm_streq0 (cached.module_name, module_name), NULL);
+	} else {
+		gpointer factory;
+		void *dl_module;
+
+		dl_module = dlopen (module_path, RTLD_LAZY | RTLD_LOCAL);
+		if (!dl_module) {
+			if (!g_file_test (module_path, G_FILE_TEST_EXISTS)) {
+				g_set_error (error,
+				             G_FILE_ERROR,
+				             G_FILE_ERROR_NOENT,
+				             _("missing plugin file \"%s\""), module_path);
+				return NULL;
+			}
+			g_set_error (error,
+			             NM_VPN_PLUGIN_ERROR,
+			             NM_VPN_PLUGIN_ERROR_FAILED,
+			             _("cannot load editor plugin: %s"), dlerror ());
+			return NULL;
+		}
+
+		factory = dlsym (dl_module, factory_name);
+		if (!factory) {
+			g_set_error (error,
+			             NM_VPN_PLUGIN_ERROR,
+			             NM_VPN_PLUGIN_ERROR_FAILED,
+			             _("cannot load factory %s from plugin: %s"),
+			             factory_name, dlerror ());
+			dlclose (dl_module);
+			return NULL;
+		}
+
+		/* we cannot ever unload the module because it creates glib types, which
+		 * cannot be unregistered.
+		 *
+		 * Thus we just leak the dl_module handle indefinitely. */
+		cached.factory = factory;
+		cached.dl_module = dl_module;
+		cached.module_name = g_strdup (module_name);
+		cached.factory_name = g_strdup (factory_name);
+	}
+
+	editor = editor_factory (cached.factory,
+	                         editor_plugin,
+	                         connection,
+	                         user_data,
+	                         error);
+	if (!editor) {
+		if (error && !*error ) {
+			g_set_error_literal (error,
+			                     NM_VPN_PLUGIN_ERROR,
+			                     NM_VPN_PLUGIN_ERROR_FAILED,
+			                     _("unknown error creating editor instance"));
+			g_return_val_if_reached (NULL);
+		}
+		return NULL;
+	}
+
+	g_return_val_if_fail (NM_IS_VPN_EDITOR (editor), NULL);
+	return editor;
+}
diff --git a/shared/nm-utils/nm-vpn-plugin-utils.h b/shared/nm-utils/nm-vpn-plugin-utils.h
new file mode 100644
index 0000000..f3928d1
--- /dev/null
+++ b/shared/nm-utils/nm-vpn-plugin-utils.h
@@ -0,0 +1,42 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2016 Red Hat, Inc.
+ */
+
+#ifndef __NM_VPN_PLUGIN_UTILS_H__
+#define __NM_VPN_PLUGIN_UTILS_H__
+
+#include <NetworkManager.h>
+
+typedef NMVpnEditor *(NMVpnPluginUtilsEditorFactory) (gpointer factory,
+                                                      NMVpnEditorPlugin *editor_plugin,
+                                                      NMConnection *connection,
+                                                      gpointer user_data,
+                                                      GError **error);
+
+NMVpnEditor *nm_vpn_plugin_utils_load_editor (const char *module_name,
+                                              const char *factory_name,
+                                              NMVpnPluginUtilsEditorFactory editor_factory,
+                                              NMVpnEditorPlugin *editor_plugin,
+                                              NMConnection *connection,
+                                              gpointer user_data,
+                                              GError **error);
+
+#endif /* __NM_VPN_PLUGIN_UTILS_H__ */
+
diff --git a/src/Makefile.am b/src/Makefile.am
deleted file mode 100644
index d4783d9..0000000
--- a/src/Makefile.am
+++ /dev/null
@@ -1,24 +0,0 @@
-AM_CPPFLAGS = \
-	$(LIBNM_CFLAGS) \
-	$(GIO_CFLAGS) \
-	-DBINDIR=\"$(bindir)\" \
-	-DPREFIX=\""$(prefix)"\" \
-	-DSYSCONFDIR=\""$(sysconfdir)"\" \
-	-DLIBDIR=\""$(libdir)"\" \
-	-DLIBEXECDIR=\""$(libexecdir)"\" \
-	-DLOCALSTATEDIR=\""$(localstatedir)"\" \
-	-DDATADIR=\"$(datadir)\" \
-	-DNM_SSH_LOCALEDIR=\"$(datadir)/locale\" \
-	-I$(top_srcdir)
-
-libexec_PROGRAMS = nm-ssh-service
-
-nm_ssh_service_SOURCES = \
-	nm-ssh-service.c \
-	nm-ssh-service.h \
-	nm-ssh-service-defines.h
-
-nm_ssh_service_LDADD = \
-	$(LIBNM_LIBS) $(GIO_LIBS)
-
-CLEANFILES = *~
diff --git a/src/nm-ssh-service.h b/src/nm-ssh-service.h
index c15dc35..333fa9b 100644
--- a/src/nm-ssh-service.h
+++ b/src/nm-ssh-service.h
@@ -26,7 +26,7 @@
 #include <glib-object.h>
 #include <nm-vpn-service-plugin.h>
 
-#include "nm-ssh-service-defines.h"
+#include "nm-service-defines.h"
 
 #define NM_TYPE_SSH_PLUGIN            (nm_ssh_plugin_get_type ())
 #define NM_SSH_PLUGIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_SSH_PLUGIN, NMSshPlugin))
